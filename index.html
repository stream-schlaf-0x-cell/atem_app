<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="theme-color" content="#0a0a0a">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>Atem & Stille</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Forum&family=Tenor+Sans&display=swap" rel="stylesheet">
    <style>
        /* --- CSS STYLES --- */
        :root {
            --bg-color: #0a0a0a; --text-color: #efece6;
            --accent-primary: #4a638c; --accent-secondary: #e6c65a;
            --glass-bg: rgba(10, 10, 10, 0.65);
            --font-stack: 'Tenor Sans', 'Forum', 'Optima', 'Segoe UI Light', sans-serif;
            --safe-top: env(safe-area-inset-top, 20px);
            --safe-bottom: env(safe-area-inset-bottom, 20px);
        }
        * { box-sizing: border-box; -webkit-tap-highlight-color: transparent; }
        body {
            background-color: var(--bg-color); color: var(--text-color);
            font-family: var(--font-stack); margin: 0; height: 100dvh;
            display: flex; flex-direction: column; overflow: hidden;
            transition: background-color 2s ease; 
            overscroll-behavior: none; /* iOS Scroll Fix */
        }
        /* THEMES */
        body.theme-himmelblau { --bg-color: #0b1026; --accent-primary: #6b8c96; --glass-bg: rgba(11, 16, 38, 0.65); }
        body.theme-goldene-ruhe { --bg-color: #120c08; --accent-primary: #ba9655; --glass-bg: rgba(18, 12, 8, 0.65); }
        body.theme-lotusabend { --bg-color: #0e0b0c; --accent-primary: #a65959; --glass-bg: rgba(10,8,9,0.55); }
        body.theme-dantian-gruen { --bg-color: #071012; --accent-primary: #5d7a66; --glass-bg: rgba(8,12,10,0.56); }
        body.theme-reines-licht { --bg-color: #121212; --accent-primary: #cfd8dc; --glass-bg: rgba(18, 18, 18, 0.65); }
        body.theme-mani-glanz { --bg-color: #070709; --accent-primary: #5e7291; --glass-bg: rgba(6,6,6,0.58); }
        
        /* LAYOUT */
        #visual-area { flex-grow: 1; display: flex; flex-direction: column; align-items: center; justify-content: center; position: relative; width: 100%; height: 100%; touch-action: none; }
        .viz-canvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; display: block; touch-action: none; }
        
        .instruction-text {
            position: absolute;
            left: 50%;
            transform: translateX(-50%);
            font-size: 1.5rem;
            font-weight: 300;
            letter-spacing: 0.1em;
            padding: 20px 40px; /* Much larger hit area */
            border-radius: 12px;
            
            /* INTERACTION SETTINGS */
            pointer-events: auto !important; /* Force clickable */
            cursor: pointer;
            touch-action: manipulation; /* Improves touch response */
            z-index: 1000;
            user-select: none;
            
            opacity: 0.95;
            color: var(--text-color);
            background: linear-gradient(180deg, rgba(0,0,0,0.04), rgba(255,255,255,0.02));
            transition: transform 0.2s ease, opacity 0.3s ease, color 0.8s ease;
        }
        .instruction-text:active {
            transform: translateX(-50%) scale(0.95);
            background: rgba(255,255,255,0.1);
        }
        .instruction-text:hover {
            opacity: 1;
            text-shadow: 0 0 15px rgba(255,255,255,0.3);
        }
        
        /* CRITICAL FIX: Only disable clicks if the APP IS RUNNING, not just if UI is hidden */
        body.app-running .instruction-text {
            pointer-events: none !important;
            cursor: default;
        }

        #breath-timer {
            position: absolute; left: 50%; transform: translateX(-50%);
            font-size: 1.8rem; font-weight: 300; letter-spacing: 0.1em; color: var(--accent-secondary); background: rgba(0,0,0,0.18);
            padding: 6px 12px; border-radius: 14px; pointer-events: none; z-index: 110;
            font-variant-numeric: tabular-nums; transition: opacity 0.5s ease;
        }

        #ui-container {
            position: absolute; bottom: 0; width: 100%; background: var(--glass-bg);
            backdrop-filter: blur(15px); -webkit-backdrop-filter: blur(15px);
            border-top: 1px solid rgba(255,255,255,0.03); border-radius: 20px 20px 0 0;
            padding: 8px 20px calc(15px + var(--safe-bottom));
            transform: translateY(0); transition: transform 0.8s cubic-bezier(0.2, 0.8, 0.2, 1);
            z-index: 1000; will-change: transform;
            max-height: 80dvh; overflow-y: auto; -webkit-overflow-scrolling: touch;
            scrollbar-width: none; /* Firefox */
        }
        #ui-container.hidden { transform: translateY(110%); }
        #ui-container::-webkit-scrollbar { display: none; } /* Chrome/Safari */

        .handle { width: 35px; height: 3px; background: rgba(255,255,255,0.08); border-radius: 10px; margin: 10px auto 20px; cursor: pointer; touch-action: none; }
        .preset-scroll { display: flex; gap: 8px; overflow-x: auto; padding-bottom: 12px; margin-bottom: 12px; scrollbar-width: none; mask-image: linear-gradient(to right, black 90%, transparent 100%); -webkit-mask-image: linear-gradient(to right, black 90%, transparent 100%); }
        .preset-scroll::-webkit-scrollbar { display: none; }

        .chip { background: rgba(255,255,255,0.03); border: 1px solid rgba(255,255,255,0.05); color: rgba(255,255,255,0.5); padding: 7px 14px; border-radius: 18px; font-size: 0.85rem; white-space: nowrap; cursor: pointer; transition: all 0.4s; -webkit-tap-highlight-color: transparent; }
        .chip.active { background: rgba(255,255,255,0.08); color: var(--accent-primary); border-color: rgba(200, 200, 200, 0.1); }
        
        #duration-scroll input { width: 60px; background: rgba(255,255,255,0.03); border: 1px solid rgba(255,255,255,0.05); color: var(--text-color); padding: 7px; border-radius: 18px; font-size: 0.85rem; text-align: center; transition: all 0.4s; }
        #duration-scroll input:focus { border-color: var(--accent-primary); background: rgba(255,255,255,0.08); }

        .controls-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 12px; margin-bottom: 16px; }
        .full-width-col { grid-column: 1 / -1; }
        label { font-size: 0.7rem; text-transform: uppercase; font-weight: 500; color: rgba(255,255,255,0.25); margin-bottom: 5px; display: block; }
        input, select { width: 100%; background: rgba(0,0,0,0.15); border: 1px solid rgba(255,255,255,0.05); color: var(--text-color); padding: 10px; border-radius: 10px; font-size: 1.05rem; outline: none; appearance: none; }

        .btn { background: linear-gradient(135deg, var(--accent-primary), var(--accent-secondary)); color: #fff; border: none; padding: 16px; border-radius: 14px; font-size: 1.05rem; font-weight: 500; width: 100%; text-transform: uppercase; cursor: pointer; transition: transform 0.15s; user-select: none; }
        .btn:active { transform: scale(0.985); }
        .btn.stop-mode { background: var(--accent-primary); opacity: 0.9; }

        .mode-row { display: flex; gap: 8px; margin-bottom: 20px; justify-content: center; }

        /* Summary Overlay */
        #summary-modal { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(10, 10, 10, 0.92); backdrop-filter: blur(15px); display: flex; flex-direction: column; justify-content: center; align-items: center; z-index: 1100; padding: 30px; text-align: center; opacity: 0; pointer-events: none; transition: opacity 0.6s; }
        #summary-modal.visible { opacity: 1; pointer-events: all; }
        .summary-stat { font-size: 3.8rem; font-weight: 100; color: var(--accent-primary); margin: 15px 0; font-variant-numeric: tabular-nums; }
        .summary-quote { font-size: 1.4rem; opacity: 0.85; line-height: 1.4; margin: 20px auto 10px; max-width: 500px; }
        .summary-author { font-size: 1.05rem; opacity: 0.65; margin: 5px auto 0; font-family: sans-serif; font-weight: 300; }

        /* --- MODERN SLIDERS (Global) --- */
        /* Base Slider Reset */
        input[type=range] {
            -webkit-appearance: none; /* Remove default styling */
            width: 100%; 
            background: transparent;
            cursor: pointer;
            margin: 0;
            padding: 0; /* Important for alignment */
        }

        input[type=range]:focus { outline: none; }

        /* --- WEBKIT (Chrome, Safari, iOS) --- */
        input[type=range]::-webkit-slider-runnable-track {
            width: 100%;
            height: 6px; /* Thinner modern track */
            cursor: pointer;
            background: rgba(255, 255, 255, 0.15);
            border-radius: 3px;
            border: none;
        }

        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
            height: 18px; /* Larger hit area */
            width: 18px;
            border-radius: 50%;
            background: #ffffff;
            box-shadow: 0 2px 6px rgba(0,0,0,0.3);
            cursor: pointer;
            margin-top: -6px; /* Pulls thumb up to center it on the 6px track */
            transition: transform 0.1s ease, background 0.2s;
        }

        /* --- FIREFOX --- */
        input[type=range]::-moz-range-track {
            width: 100%;
            height: 6px;
            cursor: pointer;
            background: rgba(255, 255, 255, 0.15);
            border-radius: 3px;
            border: none;
        }

        input[type=range]::-moz-range-thumb {
            height: 18px;
            width: 18px;
            border: none;
            border-radius: 50%;
            background: #ffffff;
            box-shadow: 0 2px 6px rgba(0,0,0,0.3);
            cursor: pointer;
            transition: transform 0.1s ease, background 0.2s;
        }

        /* Hover & Active States */
        input[type=range]:active::-webkit-slider-thumb { transform: scale(1.2); }
        input[type=range]:active::-moz-range-thumb { transform: scale(1.2); }

        /* --- SPECIFIC STYLES --- */

        /* 1. Color Slider Track: Gradient Background */
        #color-slider::-webkit-slider-runnable-track {
            background: linear-gradient(to right, 
                rgb(166,89,89), rgb(93,122,102), rgb(94,114,145), 
                rgb(107,140,150), rgb(186,150,85), rgb(207,216,220));
        }
        #color-slider::-moz-range-track {
            background: linear-gradient(to right, 
                rgb(166,89,89), rgb(93,122,102), rgb(94,114,145), 
                rgb(107,140,150), rgb(186,150,85), rgb(207,216,220));
        }

        /* 2. Volume Slider: Make thumb accent-colored */
        #vol-slider::-webkit-slider-thumb { background: var(--accent-primary); }
        #vol-slider::-moz-range-thumb { background: var(--accent-primary); }

        /* TOP CONTROLS (Mobile Collapse Logic) */
        .top-ctrl {
            transition: width 0.3s cubic-bezier(0.2, 0.8, 0.2, 1), background 0.3s;
            overflow: hidden;
        }
        @media (max-width: 768px) {
            .top-ctrl { min-width: 44px !important; width: 44px !important; padding: 0 !important; justify-content: center; }
            .top-ctrl input { display: none; width: 100px; }
            
            .top-ctrl.expanded { width: 180px !important; padding: 0 15px !important; justify-content: space-between; }
            .top-ctrl.expanded input { display: block; }
            
            /* Ensure Volume Icon stays clickable */
            #vol-icon { margin: 0; }

            /* Volume Control: Icon stays right, slider expands left */
            #volume-control { flex-direction: row-reverse; }
        }

        /* Timing Toggle for Mobile */
        #timing-toggle-btn { display: none; }
        @media (max-width: 768px) {
            #timing-toggle-btn { display: block; margin: 0 auto 15px auto; width: auto; font-size: 0.8rem; padding: 8px 16px; opacity: 0.8; }
            #timing-grid { display: none; }
            #timing-grid.visible { display: grid; }
        }

        /* VOLUME CONTROL */
        #volume-control { position: fixed; top: calc(var(--safe-top) + 20px); right: 80px; display: flex; align-items: center; gap: 15px; background: rgba(0,0,0,0.2); backdrop-filter: blur(10px); -webkit-backdrop-filter: blur(10px); padding: 10px 18px; border-radius: 24px; border: 1px solid rgba(255,255,255,0.05); z-index: 250; min-width: 160px; }
        #volume-control:hover { background: rgba(0,0,0,0.4); }
        #vol-icon { width: 28px; height: 28px; fill: var(--text-color); opacity: 0.6; cursor: pointer; flex-shrink: 0; transition: opacity 0.2s; -webkit-tap-highlight-color: transparent; }

        /* COLOR CONTROL (Top Left) */
        #color-control { position: fixed; top: calc(var(--safe-top) + 20px); left: 20px; display: flex; align-items: center; gap: 15px; background: rgba(0,0,0,0.2); backdrop-filter: blur(10px); -webkit-backdrop-filter: blur(10px); padding: 10px 18px; border-radius: 24px; border: 1px solid rgba(255,255,255,0.05); z-index: 250; min-width: 160px; }
        #color-control:hover { background: rgba(0,0,0,0.4); }
        #color-icon { width: 24px; height: 24px; fill: var(--text-color); opacity: 0.6; flex-shrink: 0; }

        /* TOP RANDOM BTN */
        #top-random-btn {
            position: fixed; top: calc(var(--safe-top) + 20px); right: 20px;
            width: 44px; height: 44px; border-radius: 50%;
            background: rgba(0,0,0,0.2); backdrop-filter: blur(10px); -webkit-backdrop-filter: blur(10px);
            border: 1px solid rgba(255,255,255,0.05);
            display: flex; align-items: center; justify-content: center;
            cursor: pointer; transition: all 0.3s ease; z-index: 250;
            color: var(--text-color); opacity: 0.6;
        }
        #top-random-btn:hover { background: rgba(0,0,0,0.4); opacity: 1; transform: scale(1.05); }
        #top-random-btn svg { width: 24px; height: 24px; fill: currentColor; }

        /* XY PAD MIXER */
        #xy-pad-container { width: 100%; display: none; flex-direction: column; align-items: center; margin-bottom: 20px; }
        #xy-pad {
            width: 100%; max-width: 280px; height: 200px;
            background: rgba(255,255,255,0.03);
            border: 1px solid rgba(255,255,255,0.1);
            border-radius: 16px;
            position: relative;
            touch-action: none; /* Prevents scrolling on touch devices */
            cursor: crosshair;
            box-shadow: inset 0 0 20px rgba(0,0,0,0.2);
        }
        #xy-cursor {
            width: 24px; height: 24px;
            background: var(--accent-primary);
            border: 2px solid #fff;
            border-radius: 50%;
            position: absolute;
            top: 0; left: 0;
            transform: translate(-50%, -50%);
            pointer-events: none;
            box-shadow: 0 2px 8px rgba(0,0,0,0.5);
            transition: transform 0.1s cubic-bezier(0.2, 0.8, 0.2, 1);
        }
        #xy-pad:active #xy-cursor { transform: translate(-50%, -50%) scale(1.2); transition: none; }
        
        .xy-label {
            position: absolute;
            font-size: 0.65rem;
            color: rgba(255,255,255,0.3);
            text-transform: uppercase;
            pointer-events: none;
            font-weight: 500;
            letter-spacing: 0.05em;
        }
        .xy-tl { top: 12px; left: 12px; }
        .xy-tr { top: 12px; right: 12px; }
        .xy-bl { bottom: 12px; left: 12px; }
        .xy-br { bottom: 12px; right: 12px; }

        .xy-zone {
            position: absolute; top: 50%; transform: translate(-50%, -50%);
            font-size: 0.55rem; letter-spacing: 0.15em; 
            pointer-events: none; user-select: none;
        }
        .xy-zone-dark { left: 25%; color: rgba(255,255,255,0.12); }
        .xy-zone-light { left: 75%; color: rgba(255,255,255,0.5); text-shadow: 0 0 4px rgba(255,255,255,0.2); }

        /* Chaos Slider & New Sliders */
        .slider-group { width: 100%; max-width: 280px; margin-top: 15px; }
        .slider-group label { display: flex; justify-content: space-between; font-size: 0.75rem; opacity: 0.7; margin-bottom: 8px; text-transform: uppercase; letter-spacing: 0.05em; margin-top: 12px; }

        /* BOTTOM CONTROLS (Refresh & Timer) */
        #bottom-controls {
            position: fixed; bottom: calc(var(--safe-bottom) + 20px); right: 20px;
            display: flex; align-items: center; gap: 12px; z-index: 240;
            pointer-events: none; /* Allow clicks to pass through empty areas */
        }
        
        #menu-shuffle-btn {
            position: absolute; top: 15px; right: 20px;
            width: 44px; height: 44px; border-radius: 50%;
            background: rgba(255,255,255,0.05); border: 1px solid rgba(255,255,255,0.1);
            display: flex; align-items: center; justify-content: center;
            cursor: pointer; transition: all 0.3s ease; z-index: 20;
            color: var(--text-color); opacity: 0.6;
        }
        #menu-shuffle-btn:hover { background: rgba(255,255,255,0.15); opacity: 1; transform: scale(1.05); }
        #menu-shuffle-btn svg { width: 24px; height: 24px; fill: currentColor; }

        #session-timer { 
            position: static; /* Flex item */
            font-size: 1.1rem; font-weight: 400; color: var(--text-color); font-variant-numeric: tabular-nums;
            opacity: 0; max-width: 0; padding: 0; overflow: hidden; white-space: nowrap;
            transition: all 0.6s cubic-bezier(0.2, 0.8, 0.2, 1); pointer-events: none; 
            background: rgba(0,0,0,0.18); backdrop-filter: blur(10px); -webkit-backdrop-filter: blur(10px);
            border-radius: 14px;
        }
        #session-timer.visible { opacity: 0.8; max-width: 100px; padding: 6px 12px; pointer-events: auto; }
        #session-timer:hover { opacity: 1; }
        
        #preset-display {
            position: fixed; bottom: 35px; left: calc(50% + 125px); transform: none;
            font-size: 1.05rem; letter-spacing: 0.1em; color: rgba(255,255,255,0.9);
            background: rgba(0,0,0,0.2); backdrop-filter: blur(10px); -webkit-backdrop-filter: blur(10px);
            padding: 8px 16px; border-radius: 16px; border: 1px solid rgba(255,255,255,0.1);
            pointer-events: none; opacity: 0; transition: opacity 0.5s; z-index: 190;
            text-transform: uppercase; font-weight: 500; font-family: sans-serif;
        }
        #preset-display.visible { opacity: 1; }

        /* TEXT POSITIONS */
        .pos-top .instruction-text { top: 15%; bottom: auto; }
        .pos-top #breath-timer { top: 25%; bottom: auto; }

        .pos-center .instruction-text { top: 45%; transform: translate(-50%, -50%); }
        .pos-center #breath-timer { top: 55%; transform: translate(-50%, -50%); }

        .pos-bottom .instruction-text { top: auto; bottom: 25%; }
        .pos-bottom #breath-timer { top: auto; bottom: 15%; }

        /* Hide text when UI is visible */
        body:not(.ui-hidden) #breath-timer {
            opacity: 0 !important;
            pointer-events: none;
        }

        /* Pacer Indicators (Global) */
        #breath-timer::before {
            display: inline-block; margin-right: 4px; font-size: 0.7em; opacity: 0.7; vertical-align: 1px;
        }
        #breath-timer[data-phase="in"]::before { content: "↑"; }
        #breath-timer[data-phase="out"]::before { content: "↓"; }
        #breath-timer[data-phase="hold-full"]::before { content: "="; }
        #breath-timer[data-phase="hold-empty"]::before { content: "="; }

        /* DESKTOP TWEAKS (Keep iPad/Mobile as is) */
        @media (min-width: 1025px) {
            #ui-container { 
                max-width: 640px; left: 50%; bottom: 40px; transform: translateX(-50%); 
                border-radius: 24px; 
            }
            #ui-container.hidden { transform: translate(-50%, 130%); }
            
            .controls-grid { gap: 12px; margin-bottom: 16px; }
            input, select, .btn { padding: 12px; font-size: 1rem; }
            
            .preset-scroll { flex-wrap: wrap; justify-content: center; overflow: visible; }
        }

        /* IPAD LANDSCAPE OPTIMIZATION */
        @media (orientation: landscape) {
            .controls-grid { grid-template-columns: repeat(4, 1fr); }
            #ui-container { padding-bottom: calc(10px + var(--safe-bottom)); }
            .pos-top .instruction-text { top: 12%; }
            .pos-top #breath-timer { top: 22%; }
            .pos-bottom .instruction-text { bottom: 20%; }
        }

        /* MOBILE PLAYER LAYOUT (Symmetrical around Stop button) */
        @media (max-width: 1024px) {
            body.ui-hidden #breath-timer {
                top: auto !important; bottom: 32px !important;
                left: auto !important; right: 50% !important;
                margin-right: 120px !important; transform: none !important;
                font-size: 1.4rem !important;
            }
            #bottom-controls {
                right: auto !important; left: 50% !important;
                bottom: 32px !important; margin-left: 120px !important;
            }
            #preset-display {
                bottom: 95px !important; left: 50% !important; transform: translateX(-50%) !important;
            }
            
            /* Session Timer Tag */
            #session-timer {
                display: flex; flex-direction: column; align-items: center; line-height: 1;
            }
            #session-timer::after {
                content: 'ZEIT'; font-size: 0.5rem; opacity: 0.5; margin-top: 2px; letter-spacing: 0.1em;
            }

            /* Center Instruction Readability & Position */
            .pos-center .instruction-text {
                top: 50% !important;
                background: rgba(0,0,0,0.25); backdrop-filter: blur(8px); -webkit-backdrop-filter: blur(8px);
                border: 1px solid rgba(255,255,255,0.08);
            }
        }

        /* Mobile Summary Screen Fix */
        @media (max-width: 768px) {
            #summary-modal { overflow-y: auto; justify-content: flex-start; padding-top: 60px; touch-action: pan-y; }
            .summary-stat { font-size: 2.8rem; margin: 10px 0; }
            .summary-quote { font-size: 1.1rem; line-height: 1.4; }
            .summary-author { font-size: 0.95rem; }
            
            /* Fix Header Overlap */
            .pos-top .instruction-text { top: calc(var(--safe-top) + 60px); }
            .pos-top #breath-timer { top: calc(var(--safe-top) + 105px); }
        }

        /* RESTORE UI BUTTON */
        #restore-ui-btn {
            position: fixed;
            bottom: calc(var(--safe-bottom) + 20px);
            left: 50%;
            transform: translateX(-50%);
            width: 50px;
            height: 50px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.15);
            color: var(--text-color);
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            z-index: 900;
            
            /* Visibility Transition */
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.4s ease, transform 0.2s ease, background 0.3s;
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
        }

        /* Hover State */
        #restore-ui-btn:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: translateX(-50%) scale(1.1);
        }

        /* SVG Icon */
        #restore-ui-btn svg {
            width: 32px;
            height: 32px;
            fill: currentColor;
            opacity: 0.8;
        }

        /* THE LOGIC: Only show when body has 'ui-hidden' class */
        body.ui-hidden:not(.app-running) #restore-ui-btn {
            opacity: 1;
            pointer-events: auto;
            animation: gentlePulse 3s infinite ease-in-out;
        }

        @keyframes gentlePulse {
            0%, 100% { box-shadow: 0 0 0 0 rgba(255, 255, 255, 0); }
            50% { box-shadow: 0 0 0 10px rgba(255, 255, 255, 0.05); }
        }
    </style>
</head>
<body class="theme-lotusabend">

    <div id="visual-area" class="pos-center">
        <canvas id="viz-canvas" class="viz-canvas"></canvas>
        <div class="instruction-text" id="instruction">Atmen</div>
        <div id="breath-timer"></div>
        <div id="preset-display"></div>
        <div id="bottom-controls">
            <div id="session-timer"></div>
        </div>
        <div id="volume-control" class="top-ctrl">
            <svg id="vol-icon" viewBox="0 0 24 24"><path d="M3 9v6h4l5 5V4L7 9H3zm13.5 3c0-1.77-1.02-3.29-2.5-4.03v8.05c1.48-.73 2.5-2.25 2.5-4.02zM14 3.23v2.06c2.89.86 5 3.54 5 6.71s-2.11 5.85-5 6.71v2.06c4.01-.91 7-4.49 7-8.77s-2.99-7.86-7-8.77z"/></svg>
            <input type="range" id="vol-slider" min="0" max="1" step="0.01">
        </div>
        <div id="color-control" class="top-ctrl">
            <svg id="color-icon" viewBox="0 0 24 24"><path d="M12 3c-4.97 0-9 4.03-9 9s4.03 9 9 9c.83 0 1.5-.67 1.5-1.5 0-.39-.15-.74-.39-1.01-.23-.26-.38-.61-.38-.99 0-.83.67-1.5 1.5-1.5H16c2.76 0 5-2.24 5-5 0-4.42-4.03-8-9-8zm-5.5 9c-.83 0-1.5-.67-1.5-1.5S5.67 9 6.5 9 8 9.67 8 10.5 7.33 12 6.5 12zm3-4C8.67 8 8 7.33 8 6.5S8.67 5 9.5 5s1.5.67 1.5 1.5S10.33 8 9.5 8zm5 0c-.83 0-1.5-.67-1.5-1.5S13.67 5 14.5 5s1.5.67 1.5 1.5S15.33 8 14.5 8zm3 4c-.83 0-1.5-.67-1.5-1.5S16.67 9 17.5 9s1.5.67 1.5 1.5S18.33 12 17.5 12z"/></svg>
            <input type="range" id="color-slider" min="0" max="100" step="0.1" value="0">
        </div>
        <div id="top-random-btn" onclick="app.randomizeVisuals()">
            <svg viewBox="0 0 24 24"><path d="M10.59 9.17L5.41 4 4 5.41l5.17 5.17 1.42-1.41zM14.5 4l2.04 2.04L4 18.59 5.41 20 17.96 7.46 20 9.5V4h-5.5zM14.83 13.41l-1.41 1.41 3.13 3.13L14.5 20H20v-5.5l-2.04 2.04L14.83 13.41z"/></svg>
        </div>
    </div>

    <div id="summary-modal">
        <h2 style="font-weight: 100; opacity: 0.5; font-size: 1.8rem;">Breathwork abgeschlossen</h2>
        <div id="summary-time" class="summary-stat">0m</div>
        <p class="summary-quote" id="quote-text"></p>
        <div id="quote-author" class="summary-author"></div>
        <button class="btn" style="margin-top: 30px; width: auto; padding: 12px 35px;" onclick="app.closeSummary()">Schließen</button>
    </div>

    <div id="ui-container">
        <div class="handle"></div>
        <div id="menu-shuffle-btn" onclick="app.shuffleSession()" role="button" aria-label="Zufällig">
            <svg viewBox="0 0 24 24"><path d="M10.59 9.17L5.41 4 4 5.41l5.17 5.17 1.42-1.41zM14.5 4l2.04 2.04L4 18.59 5.41 20 17.96 7.46 20 9.5V4h-5.5zM14.83 13.41l-1.41 1.41 3.13 3.13L14.5 20H20v-5.5l-2.04 2.04L14.83 13.41z"/></svg>
        </div>

        <div class="mode-row">
            <button class="chip active" onclick="app.setVisualMode('mist', this)">Nebel</button>
            <button class="chip" onclick="app.setVisualMode('circle', this)">Kreis</button>
            <button class="chip" onclick="app.setVisualMode('ripple', this)">Welle</button>
            <button class="chip" onclick="app.setVisualMode('luma', this)">Licht</button>
        </div>

        <div style="display: flex; justify-content: center; margin-bottom: 20px;">
            <button class="chip" id="mixer-toggle" onclick="app.toggleMixer()">Visuals anpassen</button>
        </div>

        <div id="xy-pad-container">
            <div id="xy-pad">
                <div class="xy-label xy-tl">Nebel</div>
                <div class="xy-label xy-tr">Kreis</div>
                <div class="xy-label xy-bl">Welle</div>
                <div class="xy-label xy-br">Licht</div>
                <div class="xy-zone xy-zone-dark">DUNKLER</div>
                <div class="xy-zone xy-zone-light">HELLER</div>
                <div id="xy-cursor" style="left: 0%; top: 0%;"></div>
            </div>
            
            <button id="slider-toggle-btn" class="chip" style="margin-top: 15px; width: auto; font-size: 0.8rem; padding: 8px 16px; opacity: 0.8;" onclick="app.toggleSliders()">Einstellungen anzeigen</button>

            <div class="slider-group" id="viz-sliders" style="display: none;">
                <label>
                    <span>Chaos / Varianz</span>
                    <span id="chaos-val">0%</span>
                </label>
                <input type="range" id="randomness-slider" class="range-slider" min="0" max="1" step="0.01" value="0">
                
                <label>
                    <span>Intensität / Menge</span>
                    <span id="intensity-val">70%</span>
                </label>
                <input type="range" id="intensity-slider" class="range-slider" min="0.1" max="1" step="0.01" value="0.7">
                
                <label>
                    <span>Licht: Ecken</span>
                    <span id="points-val">5</span>
                </label>
                <input type="range" id="points-slider" class="range-slider" min="3" max="12" step="1" value="5">
                <div style="text-align: center; margin-top: 15px; opacity: 0.4; font-size: 0.75rem; letter-spacing: 0.1em;">
                    ↓ SCROLLEN FÜR START
                </div>
            </div>
        </div>

        <label style="margin-left: 5px;">Presets</label>
        <div class="preset-scroll">
            <button class="chip" onclick="app.loadPreset('p1', this)">5.5 : 5.5</button>
            <button class="chip" onclick="app.loadPreset('p2', this)">4 : 4</button>
            <button class="chip" onclick="app.loadPreset('p8', this)">5 : 5</button>
            <button class="chip" onclick="app.loadPreset('p3', this)">4 : 7 : 8</button>
            <button class="chip" onclick="app.loadPreset('p4', this)">5 : 5 : 5 : 5</button>
            <button class="chip" onclick="app.loadPreset('p5', this)">6 : 6</button>
            <button class="chip" onclick="app.loadPreset('p6', this)">7 : 7</button>
            <button class="chip" onclick="app.loadPreset('p7', this)">8 : 8</button>
        </div>

        <button id="timing-toggle-btn" class="chip" onclick="app.toggleTiming()">Zeit-Details anzeigen</button>
        <div class="controls-grid" id="timing-grid">
            <div><label>Einatmen</label><input type="number" id="inTime" value="5.5" min="2" step="0.5"></div>
            <div><label>Ausatmen</label><input type="number" id="outTime" value="5.5" min="2" step="0.5"></div>
            <div><label>Halten (voll)</label><input type="number" id="holdFullTime" value="0" min="0" step="1"></div>
            <div><label>Pause (leer)</label><input type="number" id="holdEmptyTime" value="0" min="0" step="1"></div>
        </div>

        <div class="controls-grid">
            <div class="full-width-col">
                <label>Audio / Musik</label>
                <div style="display:flex; gap:8px; align-items:center;">
                    <select id="soundSelect" style="flex:1;">
                        <option value="none">Stille</option>
                        <option value="gentle">Generator: Sanft</option>
                        <option value="ambient">Generator: Ambient</option>
                        <option value="bowl">Tibetische Klangschale</option>
                        <option value="water">Fließendes Wasser</option>
                        <option value="audio/accede_atem_track-5_5.mp3">Accede: Atem Track (5.5)</option>
                        <option value="audio/altus_session3.mp3">Altus: Session 3 (5.5)</option>
                        <option value="audio/yrrpheus_coherence.mp3">Yrrpheus: Coherence</option>
                    </select>
                    <input type="file" id="audioFileInput" accept="audio/*" style="display:none">
                    <button class="btn" id="uploadBtn" style="width:auto; padding:8px 10px;">+</button>
                </div>
            </div>
        </div>

        <label>Sitzungsdauer (Minuten)</label>
        <div class="preset-scroll" id="duration-scroll">
            <button class="chip active" onclick="app.setDuration(0, this)">∞ (Endlos)</button>
            <button class="chip" onclick="app.setDuration(3, this)">3</button>
            <button class="chip" onclick="app.setDuration(5, this)">5</button>
            <button class="chip" onclick="app.setDuration(10, this)">10</button>
            <button class="chip" onclick="app.setDuration(15, this)">15</button>
            <button class="chip" onclick="app.setDuration(20, this)">20</button>
            <button class="chip" onclick="app.setDuration(25, this)">25</button>
            <button class="chip" onclick="app.setDuration(30, this)">30</button>
            <input type="number" placeholder="Min" onchange="app.setDuration(this.value, null)">
        </div>

        <button class="btn" id="startBtn">Beginnen</button>
    </div>

    <button id="stop-float" class="btn stop-mode" style="display:none; position:fixed; left:50%; transform:translateX(-50%); bottom:26px; z-index:200; width:220px; box-shadow: 0 4px 15px rgba(0,0,0,0.3);">Beenden</button>

    <button id="restore-ui-btn" onclick="app.toggleUI()" aria-label="Menü öffnen">
        <svg viewBox="0 0 24 24"><path d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z"/></svg>
    </button>

    <script>
    // Optimized Simplex Noise with Zero Allocation per Call
    const GRAD3 = [[1,1],[-1,1],[1,-1],[-1,-1],[1,0],[-1,0],[1,0],[-1,0],[0,1],[0,-1],[0,1],[0,-1]];
    class SimplexNoise { 
        constructor() {
            this.p = new Uint8Array(256);
            for(let i=0;i<256;i++) this.p[i]=i;
            for(let i=0;i<256;i++) {
                let r = Math.random()*256|0, t = this.p[i];
                this.p[i] = this.p[r]; this.p[r] = t;
            }
            this.perm = new Uint8Array(512);
            for(let i=0;i<512;i++) this.perm[i] = this.p[i&255];
        }
        noise2D(x, y) {
            const F2 = 0.5*(Math.sqrt(3.0)-1.0), G2 = (3.0-Math.sqrt(3.0))/6.0;
            let s = (x+y)*F2, i = Math.floor(x+s), j = Math.floor(y+s);
            let t = (i+j)*G2, X0 = i-t, Y0 = j-t, x0 = x-X0, y0 = y-Y0;
            let i1 = x0>y0 ? 1 : 0, j1 = x0>y0 ? 0 : 1;
            let x1 = x0 - i1 + G2, y1 = y0 - j1 + G2;
            let x2 = x0 - 1.0 + 2.0*G2, y2 = y0 - 1.0 + 2.0*G2;
            let ii = i&255, jj = j&255;
            let gi0 = this.perm[ii+this.perm[jj]]%12, gi1 = this.perm[ii+i1+this.perm[jj+j1]]%12, gi2 = this.perm[ii+1+this.perm[jj+1]]%12;
            let t0 = 0.5 - x0*x0 - y0*y0, n0 = t0<0 ? 0 : t0*t0 * (GRAD3[gi0][0]*x0 + GRAD3[gi0][1]*y0);
            let t1 = 0.5 - x1*x1 - y1*y1, n1 = t1<0 ? 0 : t1*t1 * (GRAD3[gi1][0]*x1 + GRAD3[gi1][1]*y1);
            let t2 = 0.5 - x2*x2 - y2*y2, n2 = t2<0 ? 0 : t2*t2 * (GRAD3[gi2][0]*x2 + GRAD3[gi2][1]*y2);
            return 70.0 * (n0 + n1 + n2);
        }
    }

    const THEME_PALETTE = [
        { r:14, g:11, b:12,  ar:166, ag:89, ab:89  }, // Lotus
        { r:7,  g:16, b:18,  ar:93,  ag:122, ab:102 }, // Dantian
        { r:7,  g:7,  b:9,   ar:94,  ag:114, ab:145 }, // Mani
        { r:11, g:16, b:38,  ar:107, ag:140, ab:150 }, // Himmel
        { r:18, g:12, b:8,   ar:186, ag:150, ab:85  }, // Gold
        { r:18, g:18, b:18,  ar:207, ag:216, ab:220 }  // Licht
    ];

    class BreathVisuals {
        constructor(canvas) {
            this.canvas = canvas; this.ctx = this.canvas.getContext('2d', { alpha: false, desynchronized: true });
            this.noise = new SimplexNoise(); 
            this.dpr = Math.min(window.devicePixelRatio || 1, 2);
            this.width = 0; this.height = 0; this.centerX = 0; this.centerY = 0;
            this.weights = { mist: 1, circle: 0, ripple: 0, luma: 0 }; this.breathValue = 0.5; this.colors = { r:138, g:138, b:138 };
            this.bgR = 10; this.bgG = 10; this.bgB = 10;
            
            // DEFAULTS
            this.randomness = 0;
            this.intensity = 0.7; // Default 70%
            this.lumaPoints = 5;  // Default 5 corners
            
            // Optimization: Structure of Arrays (SoA) for zero-GC particles
            this.pCount = 500;
            this.p_x = new Float32Array(this.pCount);
            this.p_y = new Float32Array(this.pCount);
            this.p_vx = new Float32Array(this.pCount);
            this.p_vy = new Float32Array(this.pCount);
            this.p_life = new Float32Array(this.pCount);
            this.p_maxLife = new Float32Array(this.pCount);
            this.p_size = new Float32Array(this.pCount);
            this.p_baseAlpha = new Float32Array(this.pCount);
            
            this.particleSprite = null;
            this.phase = 'hold-empty';
            this.lastPhase = '';
            this.turnSignal = 0;
            this.initParticles = false;
            
            window.addEventListener('resize', () => this.resize(), { passive: true }); 
            this.resize(); 
            this.animate();
        }

        updateThemeColors() {
            const style = getComputedStyle(document.body);
            const hex = (style.getPropertyValue('--accent-primary') || '#8a8a8a').trim().replace('#', '');
            if (hex.length === 6) {
                const bi = parseInt(hex, 16); this.colors = { r: (bi >> 16) & 255, g: (bi >> 8) & 255, b: bi & 255 };
            }
            
            // Fix for "White Screen"
            let bgStr = style.getPropertyValue('--bg-color').trim();
            if (bgStr.startsWith('#') && bgStr.length === 7) {
                this.bgR = parseInt(bgStr.slice(1,3),16);
                this.bgG = parseInt(bgStr.slice(3,5),16);
                this.bgB = parseInt(bgStr.slice(5,7),16);
            } else if (bgStr.startsWith('rgb')) {
                const rgb = bgStr.match(/\d+/g);
                if(rgb && rgb.length === 3) {
                    this.bgR = parseInt(rgb[0]);
                    this.bgG = parseInt(rgb[1]);
                    this.bgB = parseInt(rgb[2]);
                }
            } else {
                this.bgR = 10; this.bgG = 10; this.bgB = 10;
            }
            
            this.generateSprite();
        }

        setRandomness(v) { this.randomness = v; }
        setIntensity(v) { this.intensity = v; }
        setLumaPoints(v) { this.lumaPoints = v; }

        generateSprite() {
            this.particleSprite = document.createElement('canvas');
            const s = 64; this.particleSprite.width = s; this.particleSprite.height = s;
            const ctx = this.particleSprite.getContext('2d');
            const g = ctx.createRadialGradient(s/2, s/2, 0, s/2, s/2, s/2);
            g.addColorStop(0, `rgba(${this.colors.r},${this.colors.g},${this.colors.b},1)`);
            g.addColorStop(1, `rgba(${this.colors.r},${this.colors.g},${this.colors.b},0)`);
            ctx.fillStyle = g; ctx.fillRect(0, 0, s, s);
        }

        resize() {
            const rect = this.canvas.parentElement.getBoundingClientRect();
            this.width = rect.width; this.height = rect.height;
            this.canvas.width = this.width * this.dpr; this.canvas.height = this.height * this.dpr;
            this.canvas.style.width = this.width + 'px'; this.canvas.style.height = this.height + 'px';
            this.ctx.setTransform(this.dpr, 0, 0, this.dpr, 0, 0);
            this.centerX = this.width / 2; this.centerY = this.height / 2;
            this.updateThemeColors(); 
            this.initParticles = false; // Trigger reset
        }

        setBreathState(v, p) { 
            if (p === 'out' && this.lastPhase !== 'out') {
                this.turnSignal = 1.0;
            }
            this.lastPhase = p;
            this.breathValue = Math.max(0, Math.min(1, v)); 
            this.phase = p;
        }
        
        animate() {
            requestAnimationFrame(() => this.animate());
            
            this.turnSignal *= 0.92;
            if (this.turnSignal < 0.01) this.turnSignal = 0;
            
            let totalW = 0, weightedFade = 0;
            for(let k in this.weights) {
                const w = this.weights[k];
                totalW += w; weightedFade += w * (k==='mist' ? 0.12 : 0.025);
            }
            const fade = totalW > 0.01 ? weightedFade / totalW : 0.05;

            this.ctx.globalCompositeOperation = 'source-over';
            const safeR = isNaN(this.bgR) ? 10 : this.bgR;
            const safeG = isNaN(this.bgG) ? 10 : this.bgG;
            const safeB = isNaN(this.bgB) ? 10 : this.bgB;
            this.ctx.fillStyle = `rgba(${safeR}, ${safeG}, ${safeB}, ${fade})`;
            this.ctx.fillRect(0, 0, this.width, this.height);
            this.ctx.globalCompositeOperation = 'lighter';

            if (this.weights.mist > 0.01) this.renderMist(this.weights.mist);
            
            if (this.weights.circle > 0.01) {
                this.ctx.save(); this.ctx.globalAlpha = this.weights.circle;
                this.renderCircle(); this.ctx.restore();
            }
            
            if (this.weights.ripple > 0.01) {
                this.ctx.save(); this.ctx.globalAlpha = this.weights.ripple;
                this.renderRipple(); this.ctx.restore();
            }
            
            if (this.weights.luma > 0.01) {
                this.ctx.save(); this.ctx.globalAlpha = this.weights.luma;
                this.renderLuma(); this.ctx.restore();
            }
        }

        resetParticle(i) {
            this.p_x[i] = Math.random() * this.width;
            this.p_y[i] = Math.random() * this.height;
            this.p_vx[i] = 0; 
            this.p_vy[i] = 0;
            this.p_life[i] = 0; 
            this.p_maxLife[i] = 150 + Math.random() * 250;
            this.p_size[i] = (4 + Math.random() * 24) * (this.dpr * 0.6);
            this.p_baseAlpha[i] = 0.05 + Math.random() * 0.25;
        }

        renderMist(layerOpacity) {
            if (!this.initParticles) {
                for (let i = 0; i < this.pCount; i++) this.resetParticle(i);
                this.initParticles = true;
            }

            const time = Date.now() * 0.0003;
            const center = { x: this.centerX, y: this.centerY };
            const maxR = Math.min(this.width, this.height) * 0.4;
            const targetR = 20 + (maxR * this.breathValue);

            let turbulence = 0.03;
            if (this.phase === 'hold-full') turbulence = 0.05;
            else if (this.phase === 'hold-empty') turbulence = 0.01;

            // NEW: More impact from Randomness on movement
            turbulence += this.randomness * 0.25; 
            turbulence += this.turnSignal * 0.15;
            const noiseScale = 0.0015 + (this.randomness * 0.02);

            // NEW: Intensity affects Count more drastically (0.1 to 1.0 of total particles)
            // But also clamp it so low intensity is very sparse
            const activeCount = Math.floor(this.pCount * (0.1 + this.intensity * 0.9));

            for (let i = 0; i < activeCount; i++) {
                this.p_life[i]++;
                if (this.p_life[i] > this.p_maxLife[i]) this.resetParticle(i);

                const n = this.noise.noise2D(this.p_x[i] * noiseScale, this.p_y[i] * noiseScale + time);
                const angle = n * 12.56; 
                
                this.p_vx[i] += Math.cos(angle) * turbulence;
                this.p_vy[i] += Math.sin(angle) * turbulence;

                const dx = this.p_x[i] - center.x;
                const dy = this.p_y[i] - center.y;
                const distSq = dx*dx + dy*dy;
                const dist = Math.sqrt(distSq); 
                
                const invDist = dist > 0.1 ? 1.0 / dist : 0;
                const dirX = dx * invDist;
                const dirY = dy * invDist;

                let force = 0;
                if (this.phase === 'in') {
                    force = (targetR - dist) * 0.0005; 
                    if (dist < targetR * 0.5) force += 0.002;
                } else if (this.phase === 'out') {
                    force = (targetR - dist) * 0.0008;
                } else if (this.phase === 'hold-full') {
                    force = (targetR - dist) * 0.001;
                } else {
                    force = (targetR - dist) * 0.0005;
                }

                this.p_vx[i] += dirX * force;
                this.p_vy[i] += dirY * force;
                
                this.p_vx[i] *= 0.92; 
                this.p_vy[i] *= 0.92;
                this.p_x[i] += this.p_vx[i]; 
                this.p_y[i] += this.p_vy[i];

                const lifeProg = this.p_life[i] / this.p_maxLife[i];
                let alphaMult = 0.5 + this.breathValue * 0.5;
                if (this.phase === 'out') alphaMult *= 0.8;
                
                // NEW: Intensity affects Alpha
                const alpha = Math.sin(lifeProg * Math.PI) * this.p_baseAlpha[i] * alphaMult * layerOpacity * (0.5 + this.intensity * 0.5);
                const size = this.p_size[i] * (0.8 + this.breathValue * 0.8);

                this.ctx.globalAlpha = alpha;
                if(this.particleSprite) {
                    this.ctx.drawImage(this.particleSprite, this.p_x[i] - size/2, this.p_y[i] - size/2, size, size);
                }
            }
            this.ctx.globalAlpha = 1.0;
        }

        renderCircle() {
            // 1. Calculate Base Radius (Responsive to breath, but removed the hard turnSignal jump)
            const baseScale = Math.min(this.width, this.height) * 0.3;
            const rBase = baseScale * (0.4 + this.breathValue * 0.6);

            // 2. Draw the main noisy circle outline
            this.ctx.beginPath();
            // Slightly faster noise movement for the circle border
            const time = Date.now() * (0.0003 + this.randomness * 0.0002);
            // Distortion increases with inhalation
            const distortionAmount = (20 * this.breathValue + (this.randomness * 5)) * this.intensity;
            
            for(let i=0; i<=100; i++) {
                const a = (i/100)*6.28;
                // Use noise to offset the radius
                const n = this.noise.noise2D(Math.cos(a)+time, Math.sin(a));
                const r = rBase + n * distortionAmount;
                const x = this.centerX + Math.cos(a)*r, y = this.centerY + Math.sin(a)*r;
                if(i===0) this.ctx.moveTo(x,y); else this.ctx.lineTo(x,y);
            }
            this.ctx.closePath();
            // Stroke outline
            this.ctx.strokeStyle = `rgba(${this.colors.r},${this.colors.g},${this.colors.b},${0.3 * this.intensity})`;
            this.ctx.lineWidth = 1.5;
            this.ctx.stroke();

            // 3. Main inner gradient fill (The stable core)
            const g = this.ctx.createRadialGradient(this.centerX, this.centerY, 0, this.centerX, this.centerY, rBase*1.2);
            // Core brightness varies with breath
            const coreAlpha = (0.3 + this.breathValue * 0.2) * this.intensity;
            g.addColorStop(0, `rgba(${this.colors.r},${this.colors.g},${this.colors.b},${coreAlpha})`);
            g.addColorStop(1, "rgba(0,0,0,0)");
            this.ctx.fillStyle = g;
            this.ctx.fill();

            // 4. NEW: Subtle "Gaseous" Exhale Impulse layer
            // Only draws when the turn signal is active
            if (this.turnSignal > 0.01) {
                // The gas puff extends much further than the main circle
                const gasOuterR = rBase * (1.5 + this.turnSignal * 0.5);
                const gGas = this.ctx.createRadialGradient(this.centerX, this.centerY, rBase * 0.8, this.centerX, this.centerY, gasOuterR);
                
                // It starts transparent near the existing circle edge
                gGas.addColorStop(0, `rgba(${this.colors.r},${this.colors.g},${this.colors.b},0)`);
                
                // A very soft, low opacity puff in the mid-ground
                // Alpha depends on turnSignal strength and overall intensity, kept low for subtlety.
                const gasAlpha = 0.15 * this.turnSignal * this.intensity;
                gGas.addColorStop(0.4, `rgba(${this.colors.r},${this.colors.g},${this.colors.b},${gasAlpha})`);
                
                // Fades out completely
                gGas.addColorStop(1, "rgba(0,0,0,0)");

                // Apply this subtle glow over the whole canvas area (it's masked by the gradient anyway)
                this.ctx.fillStyle = gGas;
                this.ctx.fillRect(0,0, this.width, this.height);
            }
        }

        renderRipple() {
            // Calmer speed, as requested
            const t = Date.now() * (0.0002 + this.randomness * 0.0001);
            
            const count = Math.max(3, Math.floor(8 * this.intensity));
            const maxDimension = Math.min(this.width, this.height);
            
            // Quadratic scaling for randomness: 0-30% is very slight
            const rSq = this.randomness * this.randomness;

            for(let i=0; i<count; i++) {
                const baseR = (maxDimension * 0.4) * ((i+1)/8);
                
                // 1. Breathing Signal:
                // Reduced range expansion so pacer is always dominant
                const breathRange = 0.2 + (rSq * 0.15); 
                const minScale = 1.0 - breathRange;
                const breathExpansion = baseR * (minScale + this.breathValue * breathRange);
                
                // 2. Ripple/Chaos Strength: 
                // Significantly capped. Quadratic curve keeps low values clean.
                const wobbleAmount = rSq * (10 + baseR * 0.2);

                this.ctx.beginPath();
                const segments = 60 + Math.floor(this.randomness * 40); 
                for(let s=0; s<=segments; s++) {
                    const angle = (s / segments) * Math.PI * 2;
                    
                    // Noise affects the radius
                    const n = this.noise.noise2D(Math.cos(angle) + i * 0.5, Math.sin(angle) + t);
                    
                    // Modulation: Distortion is stronger when breathing in (breathValue high)
                    const distortion = n * wobbleAmount * (0.3 + this.breathValue * 0.7);
                    
                    // The Final Radius is Pacer + Distortion. 
                    const rFinal = Math.max(0, breathExpansion + distortion);
                    
                    const x = this.centerX + Math.cos(angle) * rFinal;
                    const y = this.centerY + Math.sin(angle) * rFinal;
                    
                    if (s===0) this.ctx.moveTo(x, y); else this.ctx.lineTo(x, y);
                }
                
                this.ctx.closePath();
                this.ctx.strokeStyle = `rgba(${this.colors.r},${this.colors.g},${this.colors.b},${(0.1 + this.breathValue * 0.1) * this.intensity})`;
                this.ctx.stroke();
            }
        }

        renderLuma() {
            // 1. Licht/Glow
            const t = Date.now() * (0.0004 + this.randomness * 0.001);
            const baseR = Math.min(this.width, this.height) * 0.20; 
            const pulse = 1 + Math.sin(t) * 0.05; 
            
            const innerR = baseR * (0.5 + this.breathValue * 0.8) * pulse; 
            const outerR = baseR * (1.0 + this.breathValue * 1.0) + (this.turnSignal * (baseR * 0.4));

            // Äußerer Glow
            const g2 = this.ctx.createRadialGradient(this.centerX, this.centerY, 0, this.centerX, this.centerY, outerR);
            g2.addColorStop(0, `rgba(${this.colors.r}, ${this.colors.g}, ${this.colors.b}, ${0.02 * this.breathValue * this.intensity})`);
            g2.addColorStop(1, `rgba(${this.colors.r}, ${this.colors.g}, ${this.colors.b}, 0)`);
            
            this.ctx.fillStyle = g2;
            this.ctx.fillRect(0, 0, this.width, this.height);

            // Innerer Kern
            const g1 = this.ctx.createRadialGradient(this.centerX, this.centerY, 0, this.centerX, this.centerY, innerR);
            const alpha = (0.05 + (this.breathValue * 0.1)) * this.intensity;
            g1.addColorStop(0, `rgba(${this.colors.r}, ${this.colors.g}, ${this.colors.b}, ${alpha})`);
            g1.addColorStop(0.5, `rgba(${this.colors.r}, ${this.colors.g}, ${this.colors.b}, ${alpha * 0.3})`);
            g1.addColorStop(1, `rgba(${this.colors.r}, ${this.colors.g}, ${this.colors.b}, 0)`);

            this.ctx.beginPath();
            this.ctx.arc(this.centerX, this.centerY, innerR, 0, Math.PI * 2);
            this.ctx.fillStyle = g1;
            this.ctx.fill();
            
            // 2. Mandala Overlay
            const t2 = Date.now() * (0.0008 + this.randomness * 0.001);
            const petals = this.lumaPoints;
            const mInnerR = Math.min(this.width, this.height) * 0.1;
            const expansion = this.breathValue * (Math.min(this.width, this.height) * 0.2);
            
            this.ctx.save();
            this.ctx.translate(this.centerX, this.centerY);
            
            // Layer 1: Clockwise Mandala
            this.ctx.save();
            this.ctx.rotate(t2 * 0.15); 
            
            for (let i = 0; i < petals; i++) {
                const angle = (i / petals) * Math.PI * 2 + (t2 * 0.5);
                const noiseVal = this.noise.noise2D(Math.cos(angle) + t2 * 0.1, Math.sin(angle));
                
                this.ctx.beginPath();
                this.ctx.rotate((Math.PI * 2) / petals);
                
                for (let a = 0; a < Math.PI * 2; a += 0.1) {
                    const r = (mInnerR + expansion) + Math.sin(a * 5 + t2 * 2) * (10 * this.breathValue + this.randomness * 30);
                    const x = Math.cos(a) * r;
                    const y = Math.sin(a) * (r * 0.4);
                    
                    if (a === 0) this.ctx.moveTo(x, y);
                    else this.ctx.lineTo(x, y);
                }
                
                const hueShift = noiseVal * (30 + this.randomness * 80); 
                this.ctx.strokeStyle = `rgba(${this.colors.r + hueShift}, ${this.colors.g}, ${this.colors.b + hueShift}, ${(0.1 + this.breathValue * 0.2) * this.intensity})`;
                this.ctx.lineWidth = 1.5;
                this.ctx.stroke();
            }
            this.ctx.restore();

            // Layer 2: Counter-Clockwise Sparkle Ring
            this.ctx.save();
            this.ctx.rotate(-t2 * 0.1); 
            const sparkleCount = Math.floor(12 * this.intensity);
            for(let i=0; i<sparkleCount; i++) {
                const a = (i/sparkleCount) * Math.PI * 2;
                const n = this.noise.noise2D(Math.cos(a), Math.sin(a) + t2);
                if(n > 0) {
                    const r = (mInnerR + expansion) * 1.5 + n * 20;
                    const x = Math.cos(a) * r;
                    const y = Math.sin(a) * r;
                    
                    this.ctx.beginPath();
                    this.ctx.fillStyle = `rgba(255, 255, 255, ${n * (0.1 + this.breathValue * 0.3) * this.intensity})`;
                    this.ctx.moveTo(x, y-3);
                    this.ctx.lineTo(x+2, y);
                    this.ctx.lineTo(x, y+3);
                    this.ctx.lineTo(x-2, y);
                    this.ctx.fill();
                }
            }
            this.ctx.restore();

            this.ctx.restore();

            // 3. Final Layer
            this.ctx.save();
            this.ctx.translate(this.centerX, this.centerY);
            this.ctx.rotate(-t2 * 8.0); 
            
            const coreR = mInnerR * 0.3;
            this.ctx.beginPath();
            const spikes = this.lumaPoints * 4;
            for (let i = 0; i < spikes; i++) { 
                const a = (i / spikes) * Math.PI * 2;
                const spike = (i % 2 === 0 ? 2 : 8) * (0.5 + this.breathValue); 
                const r = coreR + spike;
                this.ctx.lineTo(Math.cos(a) * r, Math.sin(a) * r);
            }
            this.ctx.closePath();
            this.ctx.fillStyle = `rgba(255, 255, 255, ${(0.01 + this.breathValue * 0.08) * this.intensity})`;
            this.ctx.fill();
            this.ctx.strokeStyle = `rgba(255, 255, 255, ${(0.05 + this.breathValue * 0.05) * this.intensity})`;
            this.ctx.lineWidth = 0.5;
            this.ctx.stroke();
            this.ctx.restore();

            // Inner Sphere
            this.ctx.save();
            const driftX = Math.sin(t * 3) * (4 + 8 * this.breathValue);
            const driftY = Math.cos(t * 2.5) * (4 + 8 * this.breathValue);
            this.ctx.translate(this.centerX + driftX, this.centerY + driftY);
            
            const sphereR = mInnerR * 0.5;
            
            this.ctx.beginPath();
            this.ctx.arc(0, 0, sphereR * (0.6 + Math.sin(t*5)*0.05), 0, Math.PI*2);
            this.ctx.fillStyle = `rgba(0, 0, 0, ${(0.1 * this.breathValue) * this.intensity})`;
            this.ctx.fill();

            const lineCount = Math.max(1, Math.floor(4 * this.intensity));
            for(let i=0; i<lineCount; i++) {
                this.ctx.beginPath();
                this.ctx.rotate(t2 * (5.0 + i*1.5) + Math.sin(t)*0.5); 
                for(let a=0; a<=Math.PI*2; a+=0.1) {
                    const n = this.noise.noise2D(Math.cos(a) + t2 * 2, Math.sin(a) + i);
                    const r = sphereR + n * (12 * this.breathValue);
                    const x = Math.cos(a) * r;
                    const y = Math.sin(a) * (r * (0.6 + Math.sin(t2 + i)*0.3));
                    if(a===0) this.ctx.moveTo(x, y); else this.ctx.lineTo(x, y);
                }
                this.ctx.strokeStyle = `rgba(0, 0, 0, ${(0.15 + this.breathValue * 0.15) * this.intensity})`;
                this.ctx.lineWidth = 0.6;
                this.ctx.stroke();
            }
            this.ctx.restore();

            // Rands: "Etheric Field"
            const rimR = Math.min(this.width, this.height) * 0.44;
            this.ctx.save();
            this.ctx.translate(this.centerX, this.centerY);
            
            this.ctx.save();
            this.ctx.rotate(t * 0.12); 
            this.ctx.beginPath();
            const rimPoints = Math.floor(90 * this.intensity);
            for (let i = 0; i < rimPoints; i++) {
                const wobble = Math.sin(t * 2 + i * 0.1) * 0.15;
                const a = (i / rimPoints) * Math.PI * 2 + wobble;
                const n = this.noise.noise2D(Math.cos(a) * 1.5, Math.sin(a) * 1.5 + t * 0.3);
                
                if (n > -0.2) {
                    const r = rimR + (n * 50 * this.breathValue) + (Math.sin(i * 13.1 + t) * 8);
                    const x = Math.cos(a) * r;
                    const y = Math.sin(a) * r;
                    
                    this.ctx.moveTo(x, y);
                    const size = (1.0 + n * 1.5) + (this.breathValue * 1.5);
                    this.ctx.arc(x, y, Math.max(0.5, size), 0, Math.PI*2); 
                }
            }
            this.ctx.fillStyle = `rgba(${this.colors.r}, ${this.colors.g}, ${this.colors.b}, ${(0.08 + this.breathValue * 0.12) * this.intensity})`;
            this.ctx.fill();
            this.ctx.restore();

            this.ctx.restore();
        }
    }

    /* --- AUDIO ENGINE --- */
    class GentleAudio {
        constructor() { 
            this.ctx = null; this.nodes = []; 
            this.masterGain = null;
            this.volume = parseFloat(localStorage.getItem('atem-volume')) || 0.3;
            this.audioEl = new Audio();
            this.audioEl.crossOrigin = "anonymous";
            this.audioEl.loop = true;
            this.mediaSource = null;
            this.bowlBuffer = null;
            this.waterBuffer = null;
            this.currentType = 'none';
            this.genNodes = {};
            this.reverbNode = null;
            this.musicGain = null;
        }
        async init() {
            const AC = window.AudioContext || window.webkitAudioContext;
            if (!this.ctx && AC) { 
                this.ctx = new AC();
                this.masterGain = this.ctx.createGain();
                this.masterGain.gain.value = this.volume;
                this.masterGain.connect(this.ctx.destination);
                
                this.musicGain = this.ctx.createGain();
                this.musicGain.gain.value = 0.25;
                this.musicGain.connect(this.masterGain);
                
                this.reverbNode = this.ctx.createConvolver();
                this.reverbNode.buffer = this.createReverbBuffer();
                this.reverbNode.connect(this.masterGain);
                
                this.mediaSource = this.ctx.createMediaElementSource(this.audioEl);
                this.mediaSource.connect(this.musicGain);
            }
            if (this.ctx && this.ctx.state === 'suspended') {
                await this.ctx.resume();
            }
        }
        setVolume(v) {
            this.volume = parseFloat(v); localStorage.setItem('atem-volume', this.volume);
            if(this.masterGain) this.masterGain.gain.setTargetAtTime(this.volume, this.ctx.currentTime, 0.1);
        }
        createReverbBuffer() {
            const len = this.ctx.sampleRate * 3.0;
            const buf = this.ctx.createBuffer(2, len, this.ctx.sampleRate);
            for(let c=0;c<2;c++){
                const d = buf.getChannelData(c);
                for(let i=0;i<len;i++) d[i] = (Math.random()*2-1)*Math.pow(1-i/len, 3);
            }
            return buf;
        }
        async loadBowl() {
            if(this.bowlBuffer) return;
            const file = 'e-flat-tibetan-singing-bowl-struck-38746.mp3';
            try {
                let ab;
                try {
                    const resp = await fetch(file);
                    if(!resp.ok) throw new Error('404');
                    ab = await resp.arrayBuffer();
                } catch(e) {
                    const resp = await fetch('audio/' + file);
                    ab = await resp.arrayBuffer();
                }
                this.bowlBuffer = await this.ctx.decodeAudioData(ab);
            } catch(e) { console.warn("Bowl load failed", e); }
        }
        async loadWater() {
            if(this.waterBuffer) return;
            const file = 'flowing-water-loop-1-183953.mp3';
            try {
                let ab;
                try {
                    const resp = await fetch(file);
                    if(!resp.ok) throw new Error('404');
                    ab = await resp.arrayBuffer();
                } catch(e) {
                    const resp = await fetch('audio/' + file);
                    ab = await resp.arrayBuffer();
                }
                this.waterBuffer = await this.ctx.decodeAudioData(ab);
            } catch(e) { console.warn("Water load failed", e); }
        }
        updateGenerator(breathVal) {
            if ((this.currentType !== 'gentle' && this.currentType !== 'ambient') || !this.ctx) return;
            const t = this.ctx.currentTime;
            const drift = Math.sin(t * 0.2) * 4 + Math.sin(t * 0.37) * 4; 

            if (this.currentType === 'gentle') {
                const targetGain = 0.02 + (breathVal * 0.15);
                if(this.genNodes.gain) this.genNodes.gain.gain.setTargetAtTime(targetGain, t, 0.2);
                
                if(this.genNodes.oscs) {
                    this.genNodes.oscs.forEach((osc, i) => {
                        osc.detune.setTargetAtTime(drift * (i % 2 === 0 ? 1 : -1), t, 0.2);
                    });
                }
            } else if (this.currentType === 'ambient') {
                const targetFreq = 60 + (breathVal * 220);
                if(this.genNodes.filter) this.genNodes.filter.frequency.setTargetAtTime(targetFreq, t, 0.2);
                
                const targetGain = 0.08 + (breathVal * 0.04);
                if(this.genNodes.gain) this.genNodes.gain.gain.setTargetAtTime(targetGain, t, 0.2);
            }
        }
        triggerImpulse(pType) {
            if(!this.ctx) return;
            const t = this.ctx.currentTime;
            const osc = this.ctx.createOscillator();
            const g = this.ctx.createGain();
            osc.connect(g); g.connect(this.masterGain);
            if(this.reverbNode) g.connect(this.reverbNode);

            let f = 440;
            if(this.currentType === 'gentle') f = pType==='in' ? 698.46 : 523.25; 
            else f = pType==='in' ? 392.00 : 196.00; 

            osc.frequency.value = f; osc.type = 'sine';
            g.gain.setValueAtTime(0, t); g.gain.linearRampToValueAtTime(0.08, t+0.02);
            g.gain.exponentialRampToValueAtTime(0.001, t+2.5);
            osc.start(t); osc.stop(t+2.5);
            setTimeout(()=>{osc.disconnect();g.disconnect();}, 2600);
        }
        triggerBowl(semitones) {
            if(!this.bowlBuffer || !this.ctx) return;
            const src = this.ctx.createBufferSource();
            src.buffer = this.bowlBuffer;
            src.detune.value = semitones * 100;
            
            const g = this.ctx.createGain();
            g.gain.value = 0.25;
            src.connect(g); g.connect(this.masterGain);
            
            src.start(0);
            src.onended = () => { const i = this.nodes.indexOf(src); if(i>-1)this.nodes.splice(i,1); };
            this.nodes.push(src);
        }
        async play(type) {
            this.stop(); 
            this.currentType = type;
            if (!this.ctx) await this.init();
            
            if (type === 'none') return;
            
            if (type === 'bowl') { await this.loadBowl(); return; }
            
            if (type === 'water') {
                await this.loadWater();
                if(!this.waterBuffer) return;
                const src = this.ctx.createBufferSource();
                src.buffer = this.waterBuffer;
                src.loop = true;
                const g = this.ctx.createGain();
                g.gain.value = 0; 
                g.gain.linearRampToValueAtTime(0.25, this.ctx.currentTime + 2.0);
                src.connect(g); g.connect(this.masterGain);
                src.start(0);
                this.nodes.push(src); this.nodes.push(g);
                return;
            }
            
            if (type === 'gentle' || type === 'ambient') {
                const master = this.ctx.createGain();
                master.connect(this.masterGain);
                master.gain.value = 0;
                master.gain.linearRampToValueAtTime(0.1, this.ctx.currentTime + 2.0);
                this.nodes.push(master);
                
                this.genNodes = { gain: master, oscs: [] };

                if (type === 'gentle') {
                    const freqs = [174.61, 261.63, 349.23]; 
                    freqs.forEach((f, i) => {
                        const osc = this.ctx.createOscillator();
                        osc.type = 'sine'; osc.frequency.value = f;
                        osc.detune.value = (i * 5) - 5; 
                        osc.connect(master); osc.start();
                        this.nodes.push(osc); this.genNodes.oscs.push(osc);
                    });
                } else {
                    const filter = this.ctx.createBiquadFilter();
                    filter.type = 'lowpass'; filter.frequency.value = 80; filter.Q.value = 0.5;
                    filter.connect(master); this.genNodes.filter = filter;
                    
                    [65.41, 98.00].forEach((f, i) => { 
                        const osc = this.ctx.createOscillator();
                        osc.type = i === 0 ? 'sine' : 'triangle'; 
                        osc.frequency.value = f;
                        osc.detune.value = i===0 ? -4 : 4; 
                        osc.connect(filter); osc.start();
                        this.nodes.push(osc); this.genNodes.oscs.push(osc);
                    });
                }
            } else {
                try {
                    this.audioEl.src = type;
                    this.audioEl.currentTime = 0;
                    await this.audioEl.play();
                } catch (e) {
                    console.warn("Audio play failed/aborted", e);
                }
            }
        }
        stop() { 
            this.nodes.forEach(n => { try{if(n.stop)n.stop();n.disconnect();}catch(e){} }); 
            this.nodes = []; 
            this.audioEl.pause();
        }
    }

    const quotes = [
        { id: 1, quote: "Stellt euch euren Atem als den Weg vor, der die Energie um euch herum aufnimmt und sie mit eurer eigenen Energie verbindet. Atmet aus und macht euch leer, atmet ein und füllt euer Wesen mit der Vitalität des Lebens. Visualisiert dabei, wie eure Lebenskraft zirkuliert und eure inneren Organe nährt.", source: "Nancy N. Chen", book: "Breathing Spaces [1, 2]" },
        { id: 2, quote: "In der Tonglen-Praxis atmet man zuerst ein und nimmt das Leid anderer Wesen in sich auf. Während man inhaliert, nimmt man deren Schwierigkeiten und die Ursachen ihres Kummers an. Man befreit sie dadurch symbolisch von ihrem Schmerz und den Wurzeln ihres Leidens.", source: "Shamar Rinpoche", book: "The Path to Awakening [3, 4]" },
        { id: 3, quote: "Wenn du ausatmest, stelle dir vor, dass du all dein Glück und deine positiven Umstände an andere abgibst. Dein Mitgefühl strahlt wie helles Licht aus. Dein Atem verbreitet sich überall, ähnlich wie das Spiegelbild der Sonne auf einer weiten Wasserfläche.", source: "Shamar Rinpoche", book: "The Path to Awakening [3, 4]" },
        { id: 4, quote: "Das Wesentliche im Qi Gong ist, das Herz nicht allzu sehr in den Atem zu legen, da der Atem direkt vom Bewusstsein kommt. Sobald sich das Herz regt, entsteht Atemkraft, denn die Atemtätigkeit ist ursprünglich verwandelte Herztätigkeit. Man vereinigt die innere Ruhe mit dem Rhythmus des Atems.", source: "Meister Lü Dsu (via Olvedi)", book: "Das Stille Qi Gong [5, 6]" },
        { id: 5, quote: "Der Mensch fungiert als Leiter und Transformator der universellen Lebensenergie. Zwischen Himmel und Erde entsteht ein natürlicher Fluss, in dem wir uns als Nutznießer dieses Stromes befinden. Durch die richtige Ausrichtung wird dieser Fluss intensiviert.", source: "Günther Dogan", book: "Professionelles Qi Gong [7, 8]" },
        { id: 6, quote: "Die beste Atmung im Qi Gong ist die sanfteste, am weitesten reduzierte Atmung. Dies ist nicht das Ergebnis eines Zwangs, sondern ein natürlicher Prozess der inneren Stille. Je mehr der Atem auf natürliche Weise zur Ruhe kommt, desto wirkungsvoller wird die Arbeit mit der Energie.", source: "Ulli Olvedi", book: "Das Stille Qi Gong [9]" },
        { id: 7, quote: "Höre nicht nur  mit deinen Ohren, sondern mit dem Atem. Dieser Prozess beinhaltet eine tiefe Verbindung zum eigenen Inneren, um den Körper zu erneuern. Der Atem ist das zentrale Prinzip, das Körper, Selbst und Umwelt miteinander verbindet.", source: "Nancy N. Chen", book: "Breathing Spaces [10, 11]" },
        { id: 8, quote: "In der Einfachheit der natürlichen Dinge liegen die größten Wirkkräfte. Das Atmen und die Nahrungsaufnahme sind Vorgänge, die jedes Kind beherrscht, und die in Wirklichkeit doch komplexer sind. Wir suchen im Qi Gong die grundlegende Einfachheit der Schöpfung.", source: "Günther Dogan", book: "Professionelles Qi Gong [12, 13]" },
        { id: 9, quote: "Wenn du atmest, ist es die Natur, die dich atmet. In der tiefen Praxis können Geist und Körper leer werden, bis das Innere und Äußere zu einem einheitlichen Feld verschmelzen. In diesem Zustand gibt es keinen getrennten Teil mehr – kein isoliertes Ich.", source: "Ken Cohen", book: "The Essential Qigong Training Guide [14]" },
        { id: 10, quote: "Der Atemrhythmus ist eine Funktion unseres Bewusstseins, in der Welt zu sein. Atemmuster sind anpassungsfähig und bilden eine körperliche Umgebung, die durch unsere Emotionen strukturiert wird. Heilende Atemzüge betonen das tiefe Atmen aus der Mitte des Körpers.", source: "Nancy N. Chen", book: "Breathing Spaces [15]" },
        { id: 11, quote: "Das Geheimnis des Atmens liegt in der Aufnahme von Lebenskraft aus der Luft. Die Luft ist eine der primären Quellen für unseren Organismus. Wir nutzen diesen Umstand bewusst, um unseren energetischen Zustand zu steigern und die Vitalität zu fördern.", source: "Günther Dogan", book: "Professionelles Qi Gong [16]" },
        { id: 12, quote: "Wenn du die Gelenke lockerst und die Muskeln entspannst, verbesserst du deine energetische Leitfähigkeit. Die Energie möchte immer frei fließen wie ein ungestörter Fluss. Blockaden im Geist erzeugen unweigerlich Blockaden im physischen Körper.", source: "Günther Dogan", book: "Professionelles Tai Chi Chuan [17, 18]" },
        { id: 13, quote: "Stimmen Sie Ihren Körper, Ihren Atem und Ihren Geist aufeinander ab. Sobald dieses Instrument gestimmt ist, können Sie die Feinheiten des Lebens lernen und schöne Musik machen. Ohne ein starkes Fundament im Körper kann der Geist nicht stabil bleiben.", source: "Ken Cohen", book: "The Essential Qigong Training Guide [19]" },
        { id: 14, quote: "Wenn die Stille ihren Höhepunkt erreicht hat, erzeugt sie ganz von selbst die Bewegung der Energie. Der Atem sollte dabei sehr sanft sein und niemals angestrengt wirken. In der fortgeschrittenen Übung wird die äußere Atmung immer feiner.", source: "Meister Zhi-Chang Li (via Olvedi)", book: "Das Stille Qi Gong [20, 21]" },
        { id: 15, quote: "In der buddhistischen Praxis wird der Atem als Fahrzeug für das Bewusstsein betrachtet. Wenn die Energien im Zentralkanal zusammenströmen, lösen sich grobe Geisteszustände auf. An ihre Stelle tritt das ursprüngliche Gewahrsein des klaren Lichts.", source: "Lama Thubten Yeshe (via Olvedi)", book: "Das Stille Qi Gong [22, 23]" },
        { id: 16, quote: "Ein langer Atem ist wie ein Gebirgsbach, der ohne künstliche Dämme fließt. Er sollte glatt wie feine Seide sein und nicht grob wie Sandpapier. Durch ruhiges Atmen kultivieren wir Weisheit und Vitalität im Zentrum unseres Seins.", source: "Ken Cohen", book: "The Essential Qigong Training Guide [24, 25]" },
        { id: 17, quote: "Lebenskraft stellt den Beginn jeder organischen Kausalitätskette dar und beeinflusst direkt den Fluss in unserem Körper. Die Energie folgt dabei immer der Aufmerksamkeit deines Geistes. Wo du deine Achtsamkeit hinlenkst, dort entfaltet sich die Wirkung.", source: "Günther Dogan", book: "Professionelles Qi Gong [26, 27]" },
        { id: 18, quote: "Tonglen ist die Praxis des Gebens und Nehmens auf dem Atemzug. Das Einatmen ist wie das Lindern einer Wunde, während das Ausatmen dem Verabreichen von heilender Medizin gleicht. Es ist eine Übung, die unser Herz für die Welt öffnet.", source: "Shamar Rinpoche", book: "The Path to Awakening [3, 4]" },
        { id: 19, quote: "Der Atem ist die Verbindung, der Leim zwischen Körper, Geist und Seele. Er ist das Bindeglied zwischen unserer Wahrnehmung der inneren und der äußeren Welt. Jede Sekunde unseres Lebens hängt an diesem seidenen Faden aus Luft.", source: "Mantak Chia", book: "Tao Yoga der Liebe [10, 28]" },
        { id: 20, quote: "Ein untrainierter Geist ist wie ein Sack voll kranker Medizin, der keine Heilung bringt. Nur durch Sammlung und Ruhe in der Meditation kann Klarheit erreicht werden. Die Kraft des Geistes bestimmt, wie wir die Welt erfahren.", source: "Tsong-kha-pa", book: "Lamrim Chenmo [26, 29]" },
        { id: 21, quote: "Der Atem ist die Brücke zwischen dem Sichtbaren und dem Unsichtbaren. Durch achtsames Atmen verbinden wir uns mit der primordialen Kraft der Erde und des Himmels. Diese Harmonie ist die Grundlage für jede Form der inneren Heilung.", source: "Günther Dogan", book: "Professionelles Tai Chi Chuan [30, 31]" },
        { id: 22, quote: "Wenn Atem und Gewahrsein entspannt sind, wird wahre Weisheit erlangt. Der Atem wird hauchdünn, bis das Kommen und Gehen schließlich ganz zur Ruhe kommt. In diesem Zustand löst sich die dualistische Fixierung des Geistes auf.", source: "Jigme Lingpa", book: "Yeshe Lama [32, 33]" },
        { id: 23, quote: "Die Energie eines jeden Gedankens wird im Körper gespeichert. Wer Liebe in sich trägt, wird überall auf die transformierende Kraft der Liebe stoßen. Veredle deine Absichten, damit sie deinen Pfad durch das Leben erhellen.", source: "Mantak Chia", book: "Tao Yoga der Liebe [34, 35]" },
        { id: 24, quote: "Die Lebensenergie ist für Informationen hochempfänglich und lässt sich durch bloße Intention laden. Du kannst Qualitäten in die Energie hineinlegen, allein durch deinen Wunsch und deine Vorstellungskraft. Deine Konzentration bestimmt die Wirkung der Energie.", source: "Günther Dogan", book: "Professionelles Qi Gong [36, 37]" },
        { id: 25, quote: "In der Stille des Geistes wird die ursprüngliche Natur des Herzens offenbar. Leere das Gefäß deines Geistes von allen störenden Gedanken. Das so entstehende Vakuum wird von einer kraftvollen, klaren Energie aufgefüllt werden.", source: "Mantak Chia", book: "Tao Yoga der Liebe [38, 39]" },
        { id: 26, quote: "Durch Mitgefühl und Demut öffnen wir das Tor zu unserem wahren Potenzial. Jeder Atemzug kann eine Tat der inneren Befreiung sein. Sorge zuerst dafür, dass die Kanäle deiner Lebensenergie offen und rein sind.", source: "Tsong-kha-pa", book: "Lamrim Chenmo [40]" },
        { id: 27, quote: "Körperliche Gesundheit ist kein Endzweck, sondern die Stütze für den spirituellen Pfad. Wenn das Schiff deines Körpers beschädigt ist, wird die Seele nicht weit kommen. Pflege deinen Körper mit der gleichen Sorgfalt wie einen kostbaren Diamanten.", source: "Mantak Chia", book: "Tao Yoga der Liebe [41, 42]" },
        { id: 28, quote: "Lasse dein Gewahrsein wie einen weiten Ozean sein, in dem die Wellen der Gedanken von selbst zur Ruhe kommen. Beobachte deinen Atem, ohne ihn zu verändern, und erkenne die Stille hinter der Bewegung. Dies ist der Pfad zur Gelassenheit.", source: "Namkhai Norbu", book: "The Cycle of Day and Night [43, 44]" },
        { id: 29, quote: "Jeder Atemzug erinnert uns an unsere Verbindung zum großen Ganzen. Wir sind Transformatoren der universalen Energie und Boten des Friedens. Atme ein für dich selbst und atme aus für die ganze Welt.", source: "Shamar Rinpoche", book: "The Path to Awakening [4, 45]" },
        { id: 30, quote: "Lasse den Atem einfach so sein, wie er ist, ohne Korrekturen oder Modifikationen. In diesem unkorrigierten Zustand bleibt das momentane Gewahrsein präsent und unverändert. Alles manifestiert sich als natürliche Offenheit.", source: "Namkhai Norbu", book: "The Cycle of Day and Night [44, 46]" },
        { id: 31, quote: "Das Kultivieren der Stille lässt den Geist klar werden wie einen gereinigten Spiegel. Wenn kein störender Gedanke im Geist ist, ist der Geist in seiner reinen Natur. Diese Ruhe führt in ungeahnte Höhen der inneren Erfahrung.", source: "Ulli Olvedi", book: "Das Stille Qi Gong [47, 48]" },
        { id: 32, quote: "Atme ein: Nimm das Elend der Welt in dich auf. Während du einatmest, transformiere dieses Leiden durch dein Herz. Atme aus: Denke, dass du all dein gutes Karma und Glück an Wesen überall abgibst.", source: "Shamar Rinpoche", book: "The Path to Awakening [3, 4]" },
        { id: 33, quote: "Wenn der Körper angespannt ist, kann der Atem nicht langsam oder tief sein. Der einfachste Weg, den Geist zu ändern, besteht darin, zuerst den Körper zu entspannen. Dies ist das perfekte Gegenmittel gegen den Stress des Alltags.", source: "Ken Cohen", book: "The Essential Qigong Training Guide [49]" },
        { id: 34, quote: "Stehe fest verwurzelt wie ein Baum. Wie bei einem Baum geschieht das eigentliche Wachstum anfangs unmerklich. Geduld und Ausdauer werden sich lohnen, denn in dieser Einfachheit liegen die größten Wirkkräfte.", source: "Günther Dogan", book: "Professionelles Qi Gong [7, 24]" },
        { id: 35, quote: "In unserer Zeit wird die Spanne des Lebens oft durch Sorgen und Agitation verkürzt. Viele Krankheiten verbrauchen unsere Zeit und Energie. Nur die Praxis der Achtsamkeit kann uns helfen, die kostbare Zeit sinnvoll zu nutzen.", source: "Tsong-kha-pa", book: "Lamrim Chenmo [50]" },
        { id: 36, quote: "Bodhicitta ist der Wunsch, Erleuchtung zum Wohl aller Wesen zu erlangen. Diese altruistische Absicht ist die höchste Form der geistigen Schulung. Sie verwandelt jedes Handeln und jeden Atemzug in eine Quelle des Nutzens für andere.", source: "Shamar Rinpoche", book: "The Path to Awakening [51]" },
        { id: 37, quote: "Konzentriere dich auf die weite Offenheit des äußeren Raums. Tue dies, bis es scheint, als ob sich dein Bewusstsein völlig darin auflöst. Dann wird eine Präsenz von reinem und strahlendem Licht in deinem Herzen erscheinen.", source: "Jigme Lingpa", book: "Yeshe Lama [52, 53]" },
        { id: 38, quote: "Die Qualität deiner Empfindung bestimmt die Qualität der Energie, die du erzeugst. Wenn deine Motivation gütig ist, wird die Energie emporsteigen und den höheren Genius deines Herzens und deines Geistes aufschließen.", source: "Mantak Chia", book: "Tao Yoga der Liebe [54]" },
        { id: 39, quote: "Reine, positive und gütige Gedanken fördern die Qualität der Lebenskraft sehr stark. Das ist es, was wir während des Trainings in unserem Geist halten sollten: Dass die Kraft, die uns durchfließt, eine intelligente Heilkraft ist.", source: "Günther Dogan", book: "Professionelles Qi Gong [55, 56]" },
        { id: 40, quote: "Qi Gong bietet dem Einzelnen die Möglichkeit, Geist und Körper zu kultivieren. Durch Atemübungen und Visualisierung entstehen neue Freiräume, die den Alltag transformieren. Öffne deine Sinne für das Universum, in dem du lebst.", source: "Nancy N. Chen", book: "Breathing Spaces [1, 2]" }
    ];

    class BreathApp {
        constructor() {
            this.viz = new BreathVisuals(document.getElementById('viz-canvas'));
            this.audio = new GentleAudio();
            this.isRunning = false; 
            this.abortCtrl = null;
            this.sessionDuration = 0;
            this.startTime = 0;
            this.sessionTimerInterval = null;
            this.currentPreset = "";
            this.setupUI();
            this.randomizeVisuals();
            const p1Btn = document.querySelector(`.preset-scroll .chip[onclick*="'p1'"]`);
            this.loadPreset('p1', p1Btn);
        }

        setupUI() {
            document.getElementById('startBtn').addEventListener('click', () => this.toggle());
            document.getElementById('stop-float').addEventListener('click', () => this.stop());
            
            document.getElementById('instruction').addEventListener('click', (e) => {
                e.stopPropagation();
                if (!this.isRunning) {
                    // Quick Start: Coherence 5.5s
                    document.getElementById('inTime').value = 5.5;
                    document.getElementById('outTime').value = 5.5;
                    document.getElementById('holdFullTime').value = 0;
                    document.getElementById('holdEmptyTime').value = 0;
                    this.start();
                }
            });

            document.addEventListener('keydown', (e) => {
                if (e.code === 'Space' || e.key === ' ') {
                    e.preventDefault();
                    const summary = document.getElementById('summary-modal');
                    if (summary.classList.contains('visible')) {
                        this.closeSummary();
                    } else {
                        this.toggle();
                    }
                }
            });

            // Mobile Top Controls Toggle Logic
            const toggleTopCtrl = (id) => {
                if (window.innerWidth > 768) return;
                const el = document.getElementById(id);
                const isExpanded = el.classList.contains('expanded');
                // Collapse others to prevent overlap
                document.querySelectorAll('.top-ctrl').forEach(c => c.classList.remove('expanded'));
                if (!isExpanded) el.classList.add('expanded');
            };

            document.getElementById('volume-control').addEventListener('click', (e) => {
                if (e.target.tagName === 'INPUT') return;
                toggleTopCtrl('volume-control');
            });
            document.getElementById('color-control').addEventListener('click', (e) => {
                if (e.target.tagName === 'INPUT') return;
                toggleTopCtrl('color-control');
            });

            // Color Slider (Floating)
            document.getElementById('color-slider').addEventListener('input', (e) => {
                this.updateThemeColor(parseFloat(e.target.value));
            });
            
            document.getElementById('soundSelect').addEventListener('change', (e) => {
                const val = e.target.value;
                
                // Enforce Yrrpheus Rule: Only 5:5 allowed.
                if(val.includes('yrrpheus')) {
                    this.loadPreset('p8', document.querySelector("button[onclick*='p8']"));
                }

                if(this.isRunning) this.audio.play(val);
            });
            
            document.getElementById('uploadBtn').addEventListener('click', () => document.getElementById('audioFileInput').click());
            document.getElementById('audioFileInput').addEventListener('change', (e) => {
                if(e.target.files[0]) {
                    const url = URL.createObjectURL(e.target.files[0]);
                    const sel = document.getElementById('soundSelect');
                    const opt = document.createElement('option');
                    opt.value = url; opt.text = "♫ " + e.target.files[0].name; opt.selected = true;
                    sel.add(opt);
                    if(this.isRunning) this.audio.play(url);
                }
            });
            
            const volSlider = document.getElementById('vol-slider');
            volSlider.value = this.audio.volume;
            this.updateVolumeIcon(this.audio.volume);
            
            volSlider.addEventListener('input', (e) => {
                const v = parseFloat(e.target.value);
                this.audio.setVolume(v);
                this.updateVolumeIcon(v);
            }, { passive: true });

            document.querySelector('.handle').addEventListener('pointerup', (e) => {
                e.preventDefault();
                this.toggleUI();
            });
            
            document.getElementById('vol-icon').addEventListener('pointerup', (e) => {
                e.preventDefault();
                this.toggleMute();
            });
            
            // XY Pad Logic
            const pad = document.getElementById('xy-pad');
            const handleXY = (e) => {
                const rect = pad.getBoundingClientRect();
                const clientX = e.touches ? e.touches[0].clientX : e.clientX;
                const clientY = e.touches ? e.touches[0].clientY : e.clientY;
                
                let x = (clientX - rect.left) / rect.width;
                let y = (clientY - rect.top) / rect.height;
                x = Math.max(0, Math.min(1, x));
                y = Math.max(0, Math.min(1, y));
                this.updateXY(x, y);

                // Rule: If editing visuals via matrix, move text out of center (to top)
                const vizArea = document.getElementById('visual-area');
                if (vizArea.classList.contains('pos-center')) {
                    vizArea.classList.remove('pos-center');
                    vizArea.classList.add('pos-top');
                }
            };
            pad.addEventListener('pointerdown', (e) => {
                pad.setPointerCapture(e.pointerId);
                pad.addEventListener('pointermove', handleXY);
                pad.addEventListener('pointerup', () => pad.removeEventListener('pointermove', handleXY), { once: true });
                handleXY(e);
            });

            // Randomness Slider
            document.getElementById('randomness-slider').addEventListener('input', (e) => {
                const v = parseFloat(e.target.value);
                this.viz.setRandomness(v);
                document.getElementById('chaos-val').innerText = Math.round(v * 100) + '%';
            });

            // Intensity Slider
            document.getElementById('intensity-slider').addEventListener('input', (e) => {
                const v = parseFloat(e.target.value);
                this.viz.setIntensity(v);
                document.getElementById('intensity-val').innerText = Math.round(v * 100) + '%';
            });

            // Points Slider
            document.getElementById('points-slider').addEventListener('input', (e) => {
                const v = parseInt(e.target.value);
                this.viz.setLumaPoints(v);
                document.getElementById('points-val').innerText = v;
            });
            
            // Watch for manual time changes to enforce Yrrpheus rule
            const timeInputs = document.querySelectorAll('.controls-grid input');
            timeInputs.forEach(input => {
                input.addEventListener('change', () => {
                    const snd = document.getElementById('soundSelect').value;
                    if(snd.includes('yrrpheus')) {
                        // User trying to change time while Yrrpheus is active.
                        // Switch audio back to Bowl to respect the "never play with other preset" rule.
                        document.getElementById('soundSelect').value = 'bowl';
                        if(this.isRunning) this.audio.play('bowl');
                    }
                });
            });

            // Ensure sliders match internal defaults (fixes browser caching)
            document.getElementById('randomness-slider').value = this.viz.randomness;
            document.getElementById('chaos-val').innerText = Math.round(this.viz.randomness * 100) + '%';
            
            document.getElementById('intensity-slider').value = this.viz.intensity;
            document.getElementById('intensity-val').innerText = Math.round(this.viz.intensity * 100) + '%';
            
            document.getElementById('points-slider').value = this.viz.lumaPoints;
            document.getElementById('points-val').innerText = this.viz.lumaPoints;

            // Init Theme at 0
            this.updateThemeColor(0);
        }

        updateXY(x, y) {
            const cursor = document.getElementById('xy-cursor');
            cursor.style.left = (x * 100) + '%';
            cursor.style.top = (y * 100) + '%';
            
            this.viz.weights = {
                mist: (1-x) * (1-y),
                circle: x * (1-y),
                ripple: (1-x) * y,
                luma: x * y
            };
            
            if (x%1!==0 || y%1!==0) document.querySelectorAll('.mode-row .chip').forEach(c => c.classList.remove('active'));
        }

        updateThemeColor(val) {
            const pct = val / 100;
            const segmentCount = THEME_PALETTE.length - 1;
            const index = Math.min(Math.floor(pct * segmentCount), segmentCount - 1);
            const nextIndex = index + 1;
            const segmentSize = 1 / segmentCount;
            const segmentStart = index * segmentSize;
            const t = (pct - segmentStart) / segmentSize; // 0.0 to 1.0 within segment

            const c1 = THEME_PALETTE[index];
            const c2 = THEME_PALETTE[nextIndex];

            const lerp = (a, b, f) => a + (b - a) * f;
            
            const r = Math.round(lerp(c1.r, c2.r, t));
            const g = Math.round(lerp(c1.g, c2.g, t));
            const b = Math.round(lerp(c1.b, c2.b, t));
            
            const rA = Math.round(lerp(c1.ar, c2.ar, t));
            const gA = Math.round(lerp(c1.ag, c2.ag, t));
            const bA = Math.round(lerp(c1.ab, c2.ab, t));

            document.body.style.setProperty('--bg-color', `rgb(${r},${g},${b})`);
            document.body.style.setProperty('--accent-primary', `rgb(${rA},${gA},${bA})`);
            
            // Update Viz directly
            this.viz.bgR = r; this.viz.bgG = g; this.viz.bgB = b;
            this.viz.colors = { r: rA, g: gA, b: bA };
            this.viz.generateSprite();
        }

        randomizeVisuals() {
            const rndVal = Math.random() * 100;
            const slider = document.getElementById('color-slider');
            if(slider) {
                slider.value = rndVal;
                this.updateThemeColor(rndVal);
            }

            const modes = ['mist', 'circle', 'ripple', 'luma'];
            const randomMode = modes[Math.floor(Math.random() * modes.length)];
            const modeBtn = document.querySelector(`.mode-row .chip[onclick*="'${randomMode}'"]`);
            this.setVisualMode(randomMode, modeBtn);
            
            const positions = ['pos-top', 'pos-center', 'pos-bottom'];
            const randomPos = positions[Math.floor(Math.random() * positions.length)];
            const vizArea = document.getElementById('visual-area');
            vizArea.classList.remove('pos-top', 'pos-center', 'pos-bottom');
            vizArea.classList.add(randomPos);
        }

        shuffleSession() {
            this.randomizeVisuals();
            
            const opts = Array.from(document.getElementById('soundSelect').options);
            const valid = opts.filter(o => o.value !== 'none').map(o => o.value);
            const rndSound = valid[Math.floor(Math.random() * valid.length)];
            
            document.getElementById('soundSelect').value = rndSound;
            
            // Check Yrrpheus Constraint
            if(rndSound.includes('yrrpheus')) {
                this.loadPreset('p8', document.querySelector("button[onclick*='p8']"));
            } else {
                 if(this.isRunning) this.audio.play(rndSound);
            }

            this.setDuration(0, document.querySelector('#duration-scroll .chip:first-child'));
        }

        loadPreset(k, el) {
            const presets = { 
                p1:[5.5,5.5], p2:[4,4], p3:[4,7,8], p4:[5,5,5,5], 
                p5:[6,6], p6:[7,7], p7:[8,8], p8:[5,5] 
            };
            const v = presets[k];
            if(!v) return;

            // Strict Check: If current sound is Yrrpheus, only allow p8 (5:5)
            // If user clicks another preset, switch sound back to default (Bowl)
            const currentSound = document.getElementById('soundSelect').value;
            if (currentSound.includes('yrrpheus') && k !== 'p8') {
                 document.getElementById('soundSelect').value = 'bowl';
                 if(this.isRunning) this.audio.play('bowl');
            }

            if(el) this.currentPreset = el.innerText;

            document.getElementById('inTime').value = v[0];
            document.getElementById('holdFullTime').value = v.length>2?v[1]:0;
            document.getElementById('outTime').value = v.length>2?v[2]:v[1];
            document.getElementById('holdEmptyTime').value = v.length==4?v[3]:0;

            const soundSelect = document.getElementById('soundSelect');
            if (k === 'p8') {
                // p8 is compatible with Yrrpheus, but we don't force it unless already selected or user wants it
                // Logic remains: Preset changes numbers. Sound changes sound.
                // But specific p8 logic requested previously:
                if(!soundSelect.value.includes('yrrpheus')) soundSelect.value = "audio/yrrpheus_coherence.mp3";
            } else if (k === 'p1') {
                soundSelect.value = "bowl";
            }
            
            if (this.isRunning) this.audio.play(soundSelect.value);

            document.querySelectorAll('.preset-scroll .chip').forEach(c=>c.classList.remove('active'));
            if(el) el.classList.add('active');
        }
        
        setVisualMode(mode, el) {
            let x=0, y=0;
            if(mode === 'mist') { x=0; y=0; }
            else if(mode === 'circle') { x=1; y=0; }
            else if(mode === 'ripple') { x=0; y=1; }
            else if(mode === 'luma') { x=1; y=1; }
            this.updateXY(x, y);
            
            document.querySelectorAll('.mode-row .chip').forEach(c=>c.classList.remove('active'));
            if(el) el.classList.add('active');
        }

        setDuration(min, el) {
            this.sessionDuration = parseInt(min);
            document.querySelectorAll('#duration-scroll .chip').forEach(c=>c.classList.remove('active'));
            if(el) el.classList.add('active');
        }

        toggleMute() {
            const slider = document.getElementById('vol-slider');
            if (this.audio.volume > 0) {
                this.audio.setVolume(0);
                slider.value = 0;
                this.updateVolumeIcon(0);
            } else {
                this.updateVolumeIcon(1); 
            }
        }

        updateVolumeIcon(vol) {
            const path = document.querySelector('#vol-icon path');
            const isMuted = vol <= 0.01;
            document.getElementById('vol-icon').style.opacity = isMuted ? 0.5 : 0.9;
            if(isMuted) path.setAttribute('d', 'M16.5 12c0-1.77-1.02-3.29-2.5-4.03v2.21l2.45 2.45c.03-.2.05-.41.05-.63zm2.5 0c0 .94-.2 1.82-.54 2.64l1.51 1.51C20.63 14.91 21 13.5 21 12c0-4.28-2.99-7.86-7-8.77v2.06c2.89.86 5 3.54 5 6.71zM4.27 3L3 4.27 7.73 9H3v6h4l5 5v-6.73l4.25 4.25c-.67.52-1.42.93-2.25 1.18v2.06c1.38-.31 2.63-.95 3.69-1.81L19.73 21 21 19.73l-9-9L4.27 3zM12 4L9.91 6.09 12 8.18V4z');
            else path.setAttribute('d', 'M3 9v6h4l5 5V4L7 9H3zm13.5 3c0-1.77-1.02-3.29-2.5-4.03v8.05c1.48-.73 2.5-2.25 2.5-4.02zM14 3.23v2.06c2.89.86 5 3.54 5 6.71s-2.11 5.85-5 6.71v2.06c4.01-.91 7-4.49 7-8.77s-2.99-7.86-7-8.77z');
        }
        
        toggleMixer() {
            const el = document.getElementById('xy-pad-container');
            const btn = document.getElementById('mixer-toggle');
            const isHidden = el.style.display === 'none';
            el.style.display = isHidden ? 'flex' : 'none';
            if(isHidden) {
                btn.classList.add('active');
                setTimeout(() => {
                    const ui = document.getElementById('ui-container');
                    ui.scrollBy({ top: 150, behavior: 'smooth' });
                }, 50);
            } else {
                btn.classList.remove('active');
            }
        }

        toggleSliders() {
            const el = document.getElementById('viz-sliders');
            const btn = document.getElementById('slider-toggle-btn');
            const isHidden = el.style.display === 'none';
            el.style.display = isHidden ? 'block' : 'none';
            btn.innerText = isHidden ? "Einstellungen verbergen" : "Einstellungen anzeigen";
            btn.classList.toggle('active', isHidden);
            if(isHidden) {
                setTimeout(() => document.getElementById('ui-container').scrollBy({ top: 100, behavior: 'smooth' }), 50);
            }
        }

        toggleTiming() {
            const el = document.getElementById('timing-grid');
            const btn = document.getElementById('timing-toggle-btn');
            const isHidden = !el.classList.contains('visible');
            if(isHidden) {
                el.classList.add('visible');
                btn.innerText = "Zeit-Details verbergen";
                btn.classList.add('active');
            } else {
                el.classList.remove('visible');
                btn.innerText = "Zeit-Details anzeigen";
                btn.classList.remove('active');
            }
        }

        toggleUI() { 
            const ui = document.getElementById('ui-container');
            const isOpening = ui.classList.contains('hidden');
            ui.classList.toggle('hidden'); 
            document.body.classList.toggle('ui-hidden');

            if (isOpening && !this.isRunning) {
                document.getElementById('xy-pad-container').style.display = 'none';
                document.getElementById('mixer-toggle').classList.remove('active');
            }
        }
        closeSummary() { document.getElementById('summary-modal').classList.remove('visible'); }
        
        async toggle() { this.isRunning ? this.stop() : this.start(); }

        async start() {
            if (this.isRunning) return;
            
            const btn = document.getElementById('startBtn');
            const oldText = btn.innerText;
            btn.innerText = "Laden...";
            btn.disabled = true;

            try {
                await this.audio.init();
                await this.audio.play(document.getElementById('soundSelect').value);
                if(navigator.wakeLock) try { this.wakelock = await navigator.wakeLock.request('screen'); } catch(e){}

                this.isRunning = true;
                this.startTime = Date.now();
                
                document.getElementById('ui-container').classList.add('hidden');
                document.body.classList.add('ui-hidden');
                document.body.classList.add('app-running');
                document.getElementById('summary-modal').classList.remove('visible');
                btn.innerText = "Beenden";
                btn.classList.add('stop-mode');
                btn.disabled = false;
                document.getElementById('stop-float').style.display = 'block';
                
                document.getElementById('preset-display').innerText = this.currentPreset || "Freies Atmen";
                document.getElementById('preset-display').classList.add('visible');
                
                if(this.abortCtrl) this.abortCtrl.abort();
                this.abortCtrl = new AbortController();
                
                this.loop(this.abortCtrl.signal);

                document.getElementById('session-timer').classList.add('visible');
                this.updateSessionTimer();
                if(this.sessionTimerInterval) clearInterval(this.sessionTimerInterval);
                this.sessionTimerInterval = setInterval(() => this.updateSessionTimer(), 1000);
                
            } catch (err) {
                console.error(err);
                this.isRunning = false;
                btn.innerText = oldText;
                btn.disabled = false;
            }
        }

        getUniqueQuote() {
            let history = [];
            try { history = JSON.parse(localStorage.getItem('atem-quote-history')) || []; } catch(e){}
            
            let candidates = quotes.filter(q => !history.includes(q.id));
            if (candidates.length === 0) { candidates = quotes; history = []; }
            
            const q = candidates[Math.floor(Math.random() * candidates.length)];
            
            history.push(q.id);
            if (history.length > 30) history.shift();
            localStorage.setItem('atem-quote-history', JSON.stringify(history));
            return q;
        }

        stop() {
            this.isRunning = false;
            if(this.abortCtrl) { this.abortCtrl.abort(); this.abortCtrl = null; }
            this.audio.stop();
            if(this.sessionTimerInterval) clearInterval(this.sessionTimerInterval);
            document.getElementById('session-timer').classList.remove('visible');
            document.getElementById('preset-display').classList.remove('visible');

            if(this.wakelock) this.wakelock.release();
            
            document.getElementById('ui-container').classList.remove('hidden');
            document.body.classList.remove('ui-hidden');
            document.body.classList.remove('app-running');
            document.getElementById('startBtn').innerText = "Beginnen";
            document.getElementById('startBtn').classList.remove('stop-mode');
            document.getElementById('stop-float').style.display = 'none';
            
            const instr = document.getElementById('instruction');
            instr.innerText = "Atmen";
            instr.style.color = '';
            document.getElementById('breath-timer').innerText = "";
            this.viz.setBreathState(0.5, 'hold-empty');
            
            const elapsedSec = Math.floor((Date.now() - this.startTime) / 1000);
            
            if (elapsedSec >= 30) {
                const m = Math.floor(elapsedSec / 60);
                const s = elapsedSec % 60;
                document.getElementById('summary-time').innerText = `${m} Minuten und ${s} Sekunden`;

                const q = this.getUniqueQuote();
                document.getElementById('quote-text').innerText = q.quote;
                document.getElementById('quote-author').innerText = q.source;
                document.getElementById('summary-modal').classList.add('visible');
            }
        }

        updateSessionTimer() {
            const elapsed = Date.now() - this.startTime;
            if (this.sessionDuration > 0) {
                const totalMs = this.sessionDuration * 60 * 1000;
                const remaining = Math.max(0, totalMs - elapsed);
                const m = Math.floor(remaining / 60000);
                const s = Math.floor((remaining % 60000) / 1000);
                document.getElementById('session-timer').innerText = `${m.toString().padStart(2, '0')}:${s.toString().padStart(2, '0')}`;
                if (remaining <= 0) this.stop();
            } else {
                const m = Math.floor(elapsed / 60000);
                const s = Math.floor((elapsed % 60000) / 1000);
                document.getElementById('session-timer').innerText = `${m.toString().padStart(2, '0')}:${s.toString().padStart(2, '0')}`;
            }
        }

        async loop(signal) {
            const val = id => parseFloat(document.getElementById(id).value) || 0;
            while(!signal.aborted && this.isRunning) {
                await this.phase("Einatmen", val('inTime'), 0, 1, '#82B1FF', signal, true);
                await this.phase("Halten", val('holdFullTime'), 1, 1, '#D1D1D1', signal, false);
                await this.phase("Ausatmen", val('outTime'), 1, 0, '#EF9A9A', signal, false);
                await this.phase("Pause", val('holdEmptyTime'), 0, 0, '#D1D1D1', signal, false);
            }
        }
        
        async phase(text, dur, startV, endV, col, signal, countUp) {
            if(signal.aborted || !this.isRunning || dur <= 0) return;
            
            const instr = document.getElementById('instruction');
            instr.innerText = text;
            instr.style.color = col;
            
            let pType = 'hold-empty';
            if (startV < endV) pType = 'in';
            else if (startV > endV) pType = 'out';
            else if (startV === 1) pType = 'hold-full';
            
            document.getElementById('breath-timer').setAttribute('data-phase', pType);
            
            if (this.audio.currentType === 'bowl') {
                if (pType === 'in') this.audio.triggerBowl(0);
                else if (pType === 'out') this.audio.triggerBowl(-5);
            } else if (this.audio.currentType === 'gentle' || this.audio.currentType === 'ambient') {
                if (pType === 'in' || pType === 'out') this.audio.triggerImpulse(pType);
            }
            
            const start = Date.now();
            return new Promise(resolve => {
                const tick = () => {
                    if(signal.aborted || !this.isRunning) return resolve();
                    
                    const now = Date.now();
                    const prog = Math.min(1, (now - start)/(dur*1000));
                    const eased = 0.5 * (1 - Math.cos(Math.PI * prog)); 
                    const currentBreath = startV + (endV - startV) * eased;
                    
                    this.viz.setBreathState(currentBreath, pType);
                    this.audio.updateGenerator(currentBreath);
                    
                    const timeVal = countUp ? (dur * prog) : (dur - (dur * prog));
                    const timer = document.getElementById('breath-timer');
                    timer.innerText = timeVal.toFixed(0); 
                    timer.style.color = col;
                    
                    if(prog < 1) requestAnimationFrame(tick); else resolve();
                };
                tick();
            });
        }
    }

    document.addEventListener('DOMContentLoaded', () => window.app = new BreathApp());
    </script>
</body>
</html>
