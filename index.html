<!-- START OF FILE Paste January 31, 2026 - Optimized -->
<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="theme-color" content="#0a0a0a">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>Atem & Stille</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Forum&family=Tenor+Sans&display=swap" rel="stylesheet">
    <style>
        /* --- CSS STYLES --- */
        :root {
            --bg-color: #0a0a0a; --text-color: #efece6;
            --accent-primary: #4a638c; --accent-secondary: #e6c65a;
            --glass-bg: rgba(10, 10, 10, 0.65);
            --font-stack: 'Tenor Sans', 'Forum', 'Optima', 'Segoe UI Light', sans-serif;
            --safe-top: env(safe-area-inset-top, 20px);
            --safe-bottom: env(safe-area-inset-bottom, 20px);
        }
        * { box-sizing: border-box; -webkit-tap-highlight-color: transparent; }
        body {
            background-color: var(--bg-color); color: var(--text-color);
            font-family: var(--font-stack); margin: 0; height: 100dvh;
            display: flex; flex-direction: column; overflow: hidden;
            transition: background-color 2s ease; 
            overscroll-behavior: none; /* iOS Scroll Fix */
        }
        /* THEMES */
        body.theme-himmelblau { --bg-color: #0b1026; --accent-primary: #6b8c96; --glass-bg: rgba(11, 16, 38, 0.65); }
        body.theme-goldene-ruhe { --bg-color: #120c08; --accent-primary: #ba9655; --glass-bg: rgba(18, 12, 8, 0.65); }
        body.theme-lotusabend { --bg-color: #0e0b0c; --accent-primary: #a65959; --glass-bg: rgba(10,8,9,0.55); }
        body.theme-dantian-gruen { --bg-color: #071012; --accent-primary: #5d7a66; --glass-bg: rgba(8,12,10,0.56); }
        body.theme-reines-licht { --bg-color: #121212; --accent-primary: #cfd8dc; --glass-bg: rgba(18, 18, 18, 0.65); }
        body.theme-mani-glanz { --bg-color: #070709; --accent-primary: #5e7291; --glass-bg: rgba(6,6,6,0.58); }
        
        /* LAYOUT */
        #visual-area { flex-grow: 1; display: flex; flex-direction: column; align-items: center; justify-content: center; position: relative; width: 100%; height: 100%; touch-action: none; }
        .viz-canvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; display: block; touch-action: none; }
        
        .instruction-text {
            position: absolute; left: 50%; transform: translateX(-50%);
            font-size: 1.5rem; font-weight: 300; letter-spacing: 0.1em; padding: 6px 12px; border-radius: 12px;
            pointer-events: none; opacity: 0.95; color: var(--text-color); 
            background: linear-gradient(180deg, rgba(0,0,0,0.04), rgba(255,255,255,0.02));
            z-index: 100; will-change: transform, opacity; transition: opacity 0.5s ease, color 0.8s ease;
        }
        #breath-timer {
            position: absolute; left: 50%; transform: translateX(-50%);
            font-size: 1.8rem; font-weight: 300; letter-spacing: 0.1em; color: var(--accent-secondary); background: rgba(0,0,0,0.18);
            padding: 6px 12px; border-radius: 14px; pointer-events: none; z-index: 110;
            font-variant-numeric: tabular-nums; transition: opacity 0.5s ease;
        }

        #ui-container {
            position: absolute; bottom: 0; width: 100%; background: var(--glass-bg);
            backdrop-filter: blur(15px); -webkit-backdrop-filter: blur(15px);
            border-top: 1px solid rgba(255,255,255,0.03); border-radius: 20px 20px 0 0;
            padding: 8px 20px calc(15px + var(--safe-bottom));
            transform: translateY(0); transition: transform 0.8s cubic-bezier(0.2, 0.8, 0.2, 1);
            z-index: 1000; will-change: transform;
            max-height: 80dvh; overflow-y: auto; -webkit-overflow-scrolling: touch;
            scrollbar-width: none; /* Firefox */
        }
        #ui-container.hidden { transform: translateY(110%); }
        #ui-container::-webkit-scrollbar { display: none; } /* Chrome/Safari */

        .handle { width: 35px; height: 3px; background: rgba(255,255,255,0.08); border-radius: 10px; margin: 10px auto 20px; cursor: pointer; touch-action: none; }
        .preset-scroll { display: flex; gap: 8px; overflow-x: auto; padding-bottom: 12px; margin-bottom: 12px; scrollbar-width: none; mask-image: linear-gradient(to right, black 90%, transparent 100%); -webkit-mask-image: linear-gradient(to right, black 90%, transparent 100%); }
        .preset-scroll::-webkit-scrollbar { display: none; }

        .chip { background: rgba(255,255,255,0.03); border: 1px solid rgba(255,255,255,0.05); color: rgba(255,255,255,0.5); padding: 7px 14px; border-radius: 18px; font-size: 0.85rem; white-space: nowrap; cursor: pointer; transition: all 0.4s; -webkit-tap-highlight-color: transparent; }
        .chip.active { background: rgba(255,255,255,0.08); color: var(--accent-primary); border-color: rgba(200, 200, 200, 0.1); }
        
        #duration-scroll input { width: 60px; background: rgba(255,255,255,0.03); border: 1px solid rgba(255,255,255,0.05); color: var(--text-color); padding: 7px; border-radius: 18px; font-size: 0.85rem; text-align: center; transition: all 0.4s; }
        #duration-scroll input:focus { border-color: var(--accent-primary); background: rgba(255,255,255,0.08); }

        .controls-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 12px; margin-bottom: 16px; }
        label { font-size: 0.7rem; text-transform: uppercase; font-weight: 500; color: rgba(255,255,255,0.25); margin-bottom: 5px; display: block; }
        input, select { width: 100%; background: rgba(0,0,0,0.15); border: 1px solid rgba(255,255,255,0.05); color: var(--text-color); padding: 10px; border-radius: 10px; font-size: 1.05rem; outline: none; appearance: none; }

        .btn { background: linear-gradient(135deg, var(--accent-primary), var(--accent-secondary)); color: #fff; border: none; padding: 16px; border-radius: 14px; font-size: 1.05rem; font-weight: 500; width: 100%; text-transform: uppercase; cursor: pointer; transition: transform 0.15s; user-select: none; }
        .btn:active { transform: scale(0.985); }
        .btn.stop-mode { background: var(--accent-primary); opacity: 0.9; }

        .mode-row { display: flex; gap: 8px; margin-bottom: 20px; justify-content: center; }

        /* Summary Overlay */
        #summary-modal { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(10, 10, 10, 0.92); backdrop-filter: blur(15px); display: flex; flex-direction: column; justify-content: center; align-items: center; z-index: 1100; padding: 30px; text-align: center; opacity: 0; pointer-events: none; transition: opacity 0.6s; }
        #summary-modal.visible { opacity: 1; pointer-events: all; }
        .summary-stat { font-size: 3.8rem; font-weight: 100; color: var(--accent-primary); margin: 15px 0; font-variant-numeric: tabular-nums; }
        .summary-quote { font-size: 1.4rem; opacity: 0.85; line-height: 1.4; margin: 20px auto 10px; max-width: 500px; }
        .summary-author { font-size: 1.05rem; opacity: 0.65; margin: 5px auto 0; font-family: sans-serif; font-weight: 300; }

        /* VOLUME CONTROL */
        #volume-control { position: fixed; top: calc(var(--safe-top) + 20px); right: 20px; display: flex; align-items: center; gap: 15px; background: rgba(0,0,0,0.2); backdrop-filter: blur(10px); -webkit-backdrop-filter: blur(10px); padding: 10px 18px; border-radius: 24px; border: 1px solid rgba(255,255,255,0.05); transition: background 0.3s ease; z-index: 250; width: auto; }
        #volume-control:hover { background: rgba(0,0,0,0.4); }
        #vol-icon { width: 28px; height: 28px; fill: var(--text-color); opacity: 0.6; cursor: pointer; flex-shrink: 0; transition: opacity 0.2s; -webkit-tap-highlight-color: transparent; }
        #vol-slider { width: 100px; height: 4px; -webkit-appearance: none; background: rgba(255,255,255,0.15); border-radius: 2px; outline: none; opacity: 1; cursor: pointer; touch-action: none; }
        #vol-slider::-webkit-slider-thumb { -webkit-appearance: none; width: 22px; height: 22px; border-radius: 50%; background: var(--accent-primary); cursor: pointer; transition: transform 0.1s; box-shadow: 0 2px 6px rgba(0,0,0,0.3); }
        #vol-slider::-webkit-slider-thumb:active { transform: scale(1.3); }

        /* XY PAD MIXER */
        #xy-pad-container { width: 100%; display: none; justify-content: center; margin-bottom: 20px; }
        #xy-pad {
            width: 100%; max-width: 280px; height: 200px;
            background: rgba(255,255,255,0.03);
            border: 1px solid rgba(255,255,255,0.1);
            border-radius: 16px;
            position: relative;
            touch-action: none; /* Prevents scrolling on touch devices */
            cursor: crosshair;
            box-shadow: inset 0 0 20px rgba(0,0,0,0.2);
        }
        #xy-cursor {
            width: 24px; height: 24px;
            background: var(--accent-primary);
            border: 2px solid #fff;
            border-radius: 50%;
            position: absolute;
            top: 0; left: 0;
            transform: translate(-50%, -50%);
            pointer-events: none;
            box-shadow: 0 2px 8px rgba(0,0,0,0.5);
            transition: transform 0.1s cubic-bezier(0.2, 0.8, 0.2, 1);
        }
        #xy-pad:active #xy-cursor { transform: translate(-50%, -50%) scale(1.2); transition: none; }
        
        .xy-label {
            position: absolute;
            font-size: 0.65rem;
            color: rgba(255,255,255,0.3);
            text-transform: uppercase;
            pointer-events: none;
            font-weight: 500;
            letter-spacing: 0.05em;
        }
        .xy-tl { top: 12px; left: 12px; }
        .xy-tr { top: 12px; right: 12px; }
        .xy-bl { bottom: 12px; left: 12px; }
        .xy-br { bottom: 12px; right: 12px; }

        /* BOTTOM CONTROLS (Refresh & Timer) */
        #bottom-controls {
            position: fixed; bottom: calc(var(--safe-bottom) + 20px); right: 20px;
            display: flex; align-items: center; gap: 12px; z-index: 240;
            pointer-events: none; /* Allow clicks to pass through empty areas */
        }
        
        #menu-shuffle-btn {
            position: absolute; top: 15px; right: 20px;
            width: 44px; height: 44px; border-radius: 50%;
            background: rgba(255,255,255,0.05); border: 1px solid rgba(255,255,255,0.1);
            display: flex; align-items: center; justify-content: center;
            cursor: pointer; transition: all 0.3s ease; z-index: 20;
            color: var(--text-color); opacity: 0.6;
        }
        #menu-shuffle-btn:hover { background: rgba(255,255,255,0.15); opacity: 1; transform: scale(1.05); }
        #menu-shuffle-btn svg { width: 24px; height: 24px; fill: currentColor; }

        #session-timer { 
            position: static; /* Flex item */
            font-size: 1.1rem; font-weight: 400; color: var(--text-color); font-variant-numeric: tabular-nums;
            opacity: 0; max-width: 0; padding: 0; overflow: hidden; white-space: nowrap;
            transition: all 0.6s cubic-bezier(0.2, 0.8, 0.2, 1); pointer-events: none; 
            background: rgba(0,0,0,0.18); backdrop-filter: blur(10px); -webkit-backdrop-filter: blur(10px);
            border-radius: 14px;
        }
        #session-timer.visible { opacity: 0.8; max-width: 100px; padding: 6px 12px; pointer-events: auto; }
        #session-timer:hover { opacity: 1; }
        
        #preset-display {
            position: fixed; bottom: 35px; left: calc(50% + 125px); transform: none;
            font-size: 1.05rem; letter-spacing: 0.1em; color: rgba(255,255,255,0.9);
            background: rgba(0,0,0,0.2); backdrop-filter: blur(10px); -webkit-backdrop-filter: blur(10px);
            padding: 8px 16px; border-radius: 16px; border: 1px solid rgba(255,255,255,0.1);
            pointer-events: none; opacity: 0; transition: opacity 0.5s; z-index: 190;
            text-transform: uppercase; font-weight: 500; font-family: sans-serif;
        }
        #preset-display.visible { opacity: 1; }

        /* TEXT POSITIONS */
        .pos-top .instruction-text { top: 15%; bottom: auto; }
        .pos-top #breath-timer { top: 25%; bottom: auto; }

        .pos-center .instruction-text { top: 45%; transform: translate(-50%, -50%); }
        .pos-center #breath-timer { top: 55%; transform: translate(-50%, -50%); }

        .pos-bottom .instruction-text { top: auto; bottom: 25%; }
        .pos-bottom #breath-timer { top: auto; bottom: 15%; }

        /* Hide text when UI is visible */
        body:not(.ui-hidden) .instruction-text, body:not(.ui-hidden) #breath-timer {
            opacity: 0 !important;
            pointer-events: none;
        }

        /* Pacer Indicators (Global) */
        #breath-timer::before {
            display: inline-block; margin-right: 4px; font-size: 0.7em; opacity: 0.7; vertical-align: 1px;
        }
        #breath-timer[data-phase="in"]::before { content: "↑"; }
        #breath-timer[data-phase="out"]::before { content: "↓"; }
        #breath-timer[data-phase="hold-full"]::before { content: "="; }
        #breath-timer[data-phase="hold-empty"]::before { content: "="; }

        /* DESKTOP TWEAKS (Keep iPad/Mobile as is) */
        @media (min-width: 1025px) {
            #ui-container { 
                max-width: 640px; left: 50%; bottom: 40px; transform: translateX(-50%); 
                border-radius: 24px; 
            }
            #ui-container.hidden { transform: translate(-50%, 130%); }
            
            .controls-grid { gap: 12px; margin-bottom: 16px; }
            input, select, .btn { padding: 12px; font-size: 1rem; }
            
            .preset-scroll { flex-wrap: wrap; justify-content: center; overflow: visible; }
        }

        /* IPAD LANDSCAPE OPTIMIZATION */
        @media (orientation: landscape) {
            .controls-grid { grid-template-columns: repeat(4, 1fr); }
            #ui-container { padding-bottom: calc(10px + var(--safe-bottom)); }
            .pos-top .instruction-text { top: 12%; }
            .pos-top #breath-timer { top: 22%; }
            .pos-bottom .instruction-text { bottom: 20%; }
        }

        /* MOBILE PLAYER LAYOUT (Symmetrical around Stop button) */
        @media (max-width: 1024px) {
            body.ui-hidden #breath-timer {
                top: auto !important; bottom: 32px !important;
                left: auto !important; right: 50% !important;
                margin-right: 120px !important; transform: none !important;
                font-size: 1.4rem !important;
            }
            #bottom-controls {
                right: auto !important; left: 50% !important;
                bottom: 32px !important; margin-left: 120px !important;
            }
            #preset-display {
                bottom: 95px !important; left: 50% !important; transform: translateX(-50%) !important;
            }
            
            /* Session Timer Tag */
            #session-timer {
                display: flex; flex-direction: column; align-items: center; line-height: 1;
            }
            #session-timer::after {
                content: 'ZEIT'; font-size: 0.5rem; opacity: 0.5; margin-top: 2px; letter-spacing: 0.1em;
            }

            /* Center Instruction Readability & Position */
            .pos-center .instruction-text {
                top: 50% !important;
                background: rgba(0,0,0,0.25); backdrop-filter: blur(8px); -webkit-backdrop-filter: blur(8px);
                border: 1px solid rgba(255,255,255,0.08);
            }
        }

        /* Mobile Summary Screen Fix */
        @media (max-width: 768px) {
            #summary-modal { overflow-y: auto; justify-content: flex-start; padding-top: 60px; touch-action: pan-y; }
            .summary-stat { font-size: 2.8rem; margin: 10px 0; }
            .summary-quote { font-size: 1.1rem; line-height: 1.4; }
            .summary-author { font-size: 0.95rem; }
            
            /* Fix Header Overlap */
            .pos-top .instruction-text { top: calc(var(--safe-top) + 60px); }
            .pos-top #breath-timer { top: calc(var(--safe-top) + 105px); }
        }
    </style>
</head>
<body class="theme-lotusabend">

    <div id="visual-area">
        <canvas id="viz-canvas" class="viz-canvas"></canvas>
        <div class="instruction-text" id="instruction">Atmen</div>
        <div id="breath-timer"></div>
        <div id="preset-display"></div>
        <div id="bottom-controls">
            <div id="session-timer"></div>
        </div>
        <div id="volume-control">
            <svg id="vol-icon" viewBox="0 0 24 24"><path d="M3 9v6h4l5 5V4L7 9H3zm13.5 3c0-1.77-1.02-3.29-2.5-4.03v8.05c1.48-.73 2.5-2.25 2.5-4.02zM14 3.23v2.06c2.89.86 5 3.54 5 6.71s-2.11 5.85-5 6.71v2.06c4.01-.91 7-4.49 7-8.77s-2.99-7.86-7-8.77z"/></svg>
            <input type="range" id="vol-slider" min="0" max="1" step="0.01">
        </div>
    </div>

    <div id="summary-modal">
        <h2 style="font-weight: 100; opacity: 0.5; font-size: 1.8rem;">Breathwork abgeschlossen</h2>
        <div id="summary-time" class="summary-stat">0m</div>
        <p class="summary-quote" id="quote-text"></p>
        <div id="quote-author" class="summary-author"></div>
        <button class="btn" style="margin-top: 30px; width: auto; padding: 12px 35px;" onclick="app.closeSummary()">Schließen</button>
    </div>

    <div id="ui-container">
        <div class="handle"></div>
        <div id="menu-shuffle-btn" onclick="app.shuffleSession()" role="button" aria-label="Zufällig">
            <svg viewBox="0 0 24 24"><path d="M10.59 9.17L5.41 4 4 5.41l5.17 5.17 1.42-1.41zM14.5 4l2.04 2.04L4 18.59 5.41 20 17.96 7.46 20 9.5V4h-5.5zM14.83 13.41l-1.41 1.41 3.13 3.13L14.5 20H20v-5.5l-2.04 2.04L14.83 13.41z"/></svg>
        </div>

        <div class="mode-row">
            <button class="chip active" onclick="app.setVisualMode('mist', this)">Nebel</button>
            <button class="chip" onclick="app.setVisualMode('circle', this)">Kreis</button>
            <button class="chip" onclick="app.setVisualMode('ripple', this)">Welle</button>
            <button class="chip" onclick="app.setVisualMode('luma', this)">Licht</button>
        </div>

        <div style="display: flex; justify-content: center; margin-bottom: 20px;">
            <button class="chip" id="mixer-toggle" onclick="app.toggleMixer()">Visuals anpassen</button>
        </div>

        <div id="xy-pad-container">
            <div id="xy-pad">
                <div class="xy-label xy-tl">Nebel</div>
                <div class="xy-label xy-tr">Kreis</div>
                <div class="xy-label xy-bl">Welle</div>
                <div class="xy-label xy-br">Licht</div>
                <div id="xy-cursor" style="left: 0%; top: 0%;"></div>
            </div>
        </div>

        <label style="margin-left: 5px;">Presets</label>
        <div class="preset-scroll">
            <button class="chip" onclick="app.loadPreset('p1', this)">5.5 : 5.5</button>
            <button class="chip" onclick="app.loadPreset('p2', this)">4 : 4</button>
            <button class="chip" onclick="app.loadPreset('p8', this)">5 : 5</button>
            <button class="chip" onclick="app.loadPreset('p3', this)">4 : 7 : 8</button>
            <button class="chip" onclick="app.loadPreset('p4', this)">5 : 5 : 5 : 5</button>
            <button class="chip" onclick="app.loadPreset('p5', this)">6 : 6</button>
            <button class="chip" onclick="app.loadPreset('p6', this)">7 : 7</button>
            <button class="chip" onclick="app.loadPreset('p7', this)">8 : 8</button>
        </div>

        <div class="controls-grid">
            <div><label>Einatmen</label><input type="number" id="inTime" value="5.5" min="2" step="0.5"></div>
            <div><label>Ausatmen</label><input type="number" id="outTime" value="5.5" min="2" step="0.5"></div>
            <div><label>Halten (voll)</label><input type="number" id="holdFullTime" value="0" min="0" step="1"></div>
            <div><label>Pause (leer)</label><input type="number" id="holdEmptyTime" value="0" min="0" step="1"></div>
        </div>

        <div class="controls-grid">
            <div>
                <label>Atmosphäre</label>
                <select id="themeSelect">
                    <option value="theme-lotusabend">Lotusabend</option>
                    <option value="theme-dantian-gruen">Dantian‑Grün</option>
                    <option value="theme-mani-glanz">Mani‑Glanz</option>
                    <option value="theme-himmelblau">Himmelblau</option>
                    <option value="theme-goldene-ruhe">Goldene Ruhe</option>
                    <option value="theme-reines-licht">Reines Licht</option>
                </select>
            </div>
            <div>
                <label>Audio / Musik</label>
                <div style="display:flex; gap:8px; align-items:center;">
                    <select id="soundSelect" style="flex:1;">
                        <option value="none">Stille</option>
                        <option value="gentle">Generator: Sanft</option>
                        <option value="ambient">Generator: Ambient</option>
                        <option value="bowl">Tibetische Klangschale</option>
                        <option value="water">Fließendes Wasser</option>
                        <option value="audio/accede_atem_track-5_5.mp3">Accede: Atem Track (5.5)</option>
                        <option value="audio/altus_session3.mp3">Altus: Session 3 (5.5)</option>
                        <option value="audio/yrrpheus_coherence.mp3">Yrrpheus: Coherence</option>
                    </select>
                    <input type="file" id="audioFileInput" accept="audio/*" style="display:none">
                    <button class="btn" id="uploadBtn" style="width:auto; padding:8px 10px;">+</button>
                </div>
            </div>
        </div>

        <label>Sitzungsdauer (Minuten)</label>
        <div class="preset-scroll" id="duration-scroll">
            <button class="chip active" onclick="app.setDuration(0, this)">∞ (Endlos)</button>
            <button class="chip" onclick="app.setDuration(3, this)">3</button>
            <button class="chip" onclick="app.setDuration(5, this)">5</button>
            <button class="chip" onclick="app.setDuration(10, this)">10</button>
            <button class="chip" onclick="app.setDuration(15, this)">15</button>
            <button class="chip" onclick="app.setDuration(20, this)">20</button>
            <button class="chip" onclick="app.setDuration(25, this)">25</button>
            <button class="chip" onclick="app.setDuration(30, this)">30</button>
            <input type="number" placeholder="Min" onchange="app.setDuration(this.value, null)">
        </div>

        <button class="btn" id="startBtn">Beginnen</button>
    </div>

    <button id="stop-float" class="btn stop-mode" style="display:none; position:fixed; left:50%; transform:translateX(-50%); bottom:26px; z-index:200; width:220px; box-shadow: 0 4px 15px rgba(0,0,0,0.3);">Beenden</button>

    <script>
    // Optimized Simplex Noise with Zero Allocation per Call
    const GRAD3 = [[1,1],[-1,1],[1,-1],[-1,-1],[1,0],[-1,0],[1,0],[-1,0],[0,1],[0,-1],[0,1],[0,-1]];
    class SimplexNoise { 
        constructor() {
            this.p = new Uint8Array(256);
            for(let i=0;i<256;i++) this.p[i]=i;
            for(let i=0;i<256;i++) {
                let r = Math.random()*256|0, t = this.p[i];
                this.p[i] = this.p[r]; this.p[r] = t;
            }
            this.perm = new Uint8Array(512);
            for(let i=0;i<512;i++) this.perm[i] = this.p[i&255];
        }
        noise2D(x, y) {
            const F2 = 0.5*(Math.sqrt(3.0)-1.0), G2 = (3.0-Math.sqrt(3.0))/6.0;
            let s = (x+y)*F2, i = Math.floor(x+s), j = Math.floor(y+s);
            let t = (i+j)*G2, X0 = i-t, Y0 = j-t, x0 = x-X0, y0 = y-Y0;
            let i1 = x0>y0 ? 1 : 0, j1 = x0>y0 ? 0 : 1;
            let x1 = x0 - i1 + G2, y1 = y0 - j1 + G2;
            let x2 = x0 - 1.0 + 2.0*G2, y2 = y0 - 1.0 + 2.0*G2;
            let ii = i&255, jj = j&255;
            let gi0 = this.perm[ii+this.perm[jj]]%12, gi1 = this.perm[ii+i1+this.perm[jj+j1]]%12, gi2 = this.perm[ii+1+this.perm[jj+1]]%12;
            let t0 = 0.5 - x0*x0 - y0*y0, n0 = t0<0 ? 0 : t0*t0 * (GRAD3[gi0][0]*x0 + GRAD3[gi0][1]*y0);
            let t1 = 0.5 - x1*x1 - y1*y1, n1 = t1<0 ? 0 : t1*t1 * (GRAD3[gi1][0]*x1 + GRAD3[gi1][1]*y1);
            let t2 = 0.5 - x2*x2 - y2*y2, n2 = t2<0 ? 0 : t2*t2 * (GRAD3[gi2][0]*x2 + GRAD3[gi2][1]*y2);
            return 70.0 * (n0 + n1 + n2);
        }
    }

    class BreathVisuals {
        constructor(canvas) {
            this.canvas = canvas; this.ctx = this.canvas.getContext('2d', { alpha: false, desynchronized: true });
            this.noise = new SimplexNoise(); 
            this.dpr = Math.min(window.devicePixelRatio || 1, 2);
            this.width = 0; this.height = 0; this.centerX = 0; this.centerY = 0;
            this.weights = { mist: 1, circle: 0, ripple: 0, luma: 0 }; this.breathValue = 0.5; this.colors = { r:138, g:138, b:138 };
            this.bgR = 10; this.bgG = 10; this.bgB = 10;
            
            // Optimization: Structure of Arrays (SoA) for zero-GC particles
            this.pCount = 500;
            this.p_x = new Float32Array(this.pCount);
            this.p_y = new Float32Array(this.pCount);
            this.p_vx = new Float32Array(this.pCount);
            this.p_vy = new Float32Array(this.pCount);
            this.p_life = new Float32Array(this.pCount);
            this.p_maxLife = new Float32Array(this.pCount);
            this.p_size = new Float32Array(this.pCount);
            this.p_baseAlpha = new Float32Array(this.pCount);
            
            this.particleSprite = null;
            this.phase = 'hold-empty';
            this.initParticles = false;
            
            window.addEventListener('resize', () => this.resize(), { passive: true }); 
            this.resize(); 
            this.animate();
        }

        updateThemeColors() {
            const style = getComputedStyle(document.body);
            const hex = (style.getPropertyValue('--accent-primary') || '#8a8a8a').trim().replace('#', '');
            if (hex.length === 6) {
                const bi = parseInt(hex, 16); this.colors = { r: (bi >> 16) & 255, g: (bi >> 8) & 255, b: bi & 255 };
            }
            const bgStr = style.getPropertyValue('--bg-color').trim();
            if(bgStr.startsWith('#') && bgStr.length === 7) {
                this.bgR = parseInt(bgStr.slice(1,3),16);
                this.bgG = parseInt(bgStr.slice(3,5),16);
                this.bgB = parseInt(bgStr.slice(5,7),16);
            }
            this.generateSprite();
        }

        generateSprite() {
            this.particleSprite = document.createElement('canvas');
            const s = 64; this.particleSprite.width = s; this.particleSprite.height = s;
            const ctx = this.particleSprite.getContext('2d');
            const g = ctx.createRadialGradient(s/2, s/2, 0, s/2, s/2, s/2);
            g.addColorStop(0, `rgba(${this.colors.r},${this.colors.g},${this.colors.b},1)`);
            g.addColorStop(1, `rgba(${this.colors.r},${this.colors.g},${this.colors.b},0)`);
            ctx.fillStyle = g; ctx.fillRect(0, 0, s, s);
        }

        resize() {
            const rect = this.canvas.parentElement.getBoundingClientRect();
            this.width = rect.width; this.height = rect.height;
            this.canvas.width = this.width * this.dpr; this.canvas.height = this.height * this.dpr;
            this.canvas.style.width = this.width + 'px'; this.canvas.style.height = this.height + 'px';
            this.ctx.setTransform(this.dpr, 0, 0, this.dpr, 0, 0);
            this.centerX = this.width / 2; this.centerY = this.height / 2;
            this.updateThemeColors(); 
            this.initParticles = false; // Trigger reset
        }

        setBreathState(v, p) { 
            this.breathValue = Math.max(0, Math.min(1, v)); 
            this.phase = p;
        }
        
        animate() {
            requestAnimationFrame(() => this.animate());
            
            // Dynamic Fade based on active layers
            let totalW = 0, weightedFade = 0;
            for(let k in this.weights) {
                const w = this.weights[k];
                totalW += w; weightedFade += w * (k==='mist' ? 0.12 : 0.025);
            }
            const fade = totalW > 0.01 ? weightedFade / totalW : 0.05;

            this.ctx.globalCompositeOperation = 'source-over';
            // Cache BG Color would be better, but css variable might change
            this.ctx.fillStyle = `rgba(${this.bgR}, ${this.bgG}, ${this.bgB}, ${fade})`;
            this.ctx.fillRect(0, 0, this.width, this.height);
            this.ctx.globalCompositeOperation = 'lighter';

            if (this.weights.mist > 0.01) this.renderMist(this.weights.mist);
            
            if (this.weights.circle > 0.01) {
                this.ctx.save(); this.ctx.globalAlpha = this.weights.circle;
                this.renderCircle(); this.ctx.restore();
            }
            
            if (this.weights.ripple > 0.01) {
                this.ctx.save(); this.ctx.globalAlpha = this.weights.ripple;
                this.renderRipple(); this.ctx.restore();
            }
            
            if (this.weights.luma > 0.01) {
                this.ctx.save(); this.ctx.globalAlpha = this.weights.luma;
                this.renderLuma(); this.ctx.restore();
            }
        }

        resetParticle(i) {
            this.p_x[i] = Math.random() * this.width;
            this.p_y[i] = Math.random() * this.height;
            this.p_vx[i] = 0; 
            this.p_vy[i] = 0;
            this.p_life[i] = 0; 
            this.p_maxLife[i] = 150 + Math.random() * 250;
            this.p_size[i] = (4 + Math.random() * 24) * (this.dpr * 0.6);
            this.p_baseAlpha[i] = 0.05 + Math.random() * 0.25;
        }

        renderMist(intensity) {
            if (!this.initParticles) {
                for (let i = 0; i < this.pCount; i++) this.resetParticle(i);
                this.initParticles = true;
            }

            const time = Date.now() * 0.0003;
            const center = { x: this.centerX, y: this.centerY };
            const maxR = Math.min(this.width, this.height) * 0.4;
            const targetR = 20 + (maxR * this.breathValue);

            let turbulence = 0.03;
            if (this.phase === 'hold-full') turbulence = 0.05;
            else if (this.phase === 'hold-empty') turbulence = 0.01;

            const noiseScale = 0.0015;

            for (let i = 0; i < this.pCount; i++) {
                this.p_life[i]++;
                if (this.p_life[i] > this.p_maxLife[i]) this.resetParticle(i);

                // Noise lookup - heavily optimized
                const n = this.noise.noise2D(this.p_x[i] * noiseScale, this.p_y[i] * noiseScale + time);
                const angle = n * 12.56; // 4 * PI
                
                this.p_vx[i] += Math.cos(angle) * turbulence;
                this.p_vy[i] += Math.sin(angle) * turbulence;

                const dx = this.p_x[i] - center.x;
                const dy = this.p_y[i] - center.y;
                const distSq = dx*dx + dy*dy;
                const dist = Math.sqrt(distSq); // Needed for linear force logic
                
                // Avoid division by zero
                const invDist = dist > 0.1 ? 1.0 / dist : 0;
                const dirX = dx * invDist;
                const dirY = dy * invDist;

                let force = 0;
                if (this.phase === 'in') {
                    force = (targetR - dist) * 0.0005; 
                    if (dist < targetR * 0.5) force += 0.002;
                } else if (this.phase === 'out') {
                    force = (targetR - dist) * 0.0008;
                } else if (this.phase === 'hold-full') {
                    force = (targetR - dist) * 0.001;
                } else {
                    force = (targetR - dist) * 0.0005;
                }

                this.p_vx[i] += dirX * force;
                this.p_vy[i] += dirY * force;
                
                this.p_vx[i] *= 0.92; 
                this.p_vy[i] *= 0.92;
                this.p_x[i] += this.p_vx[i]; 
                this.p_y[i] += this.p_vy[i];

                const lifeProg = this.p_life[i] / this.p_maxLife[i];
                let alphaMult = 0.5 + this.breathValue * 0.5;
                if (this.phase === 'out') alphaMult *= 0.8;
                
                const alpha = Math.sin(lifeProg * Math.PI) * this.p_baseAlpha[i] * alphaMult * intensity;
                const size = this.p_size[i] * (0.8 + this.breathValue * 0.8);

                // Direct draw (saving context save/restore for speed)
                this.ctx.globalAlpha = alpha;
                if(this.particleSprite) {
                    this.ctx.drawImage(this.particleSprite, this.p_x[i] - size/2, this.p_y[i] - size/2, size, size);
                }
            }
            this.ctx.globalAlpha = 1.0;
        }

        renderCircle() {
            const rBase = Math.min(this.width, this.height) * 0.3 * (0.4 + this.breathValue * 0.6);
            this.ctx.beginPath();
            const time = Date.now()*0.0003;
            for(let i=0; i<=100; i++) {
                const a = (i/100)*6.28;
                const n = this.noise.noise2D(Math.cos(a)+time, Math.sin(a));
                const r = rBase + n * 20 * this.breathValue;
                const x = this.centerX + Math.cos(a)*r, y = this.centerY + Math.sin(a)*r;
                if(i===0) this.ctx.moveTo(x,y); else this.ctx.lineTo(x,y);
            }
            this.ctx.closePath();
            this.ctx.strokeStyle = `rgba(${this.colors.r},${this.colors.g},${this.colors.b},0.3)`;
            this.ctx.stroke();
            const g = this.ctx.createRadialGradient(this.centerX, this.centerY, 0, this.centerX, this.centerY, rBase*1.2);
            g.addColorStop(0, `rgba(${this.colors.r},${this.colors.g},${this.colors.b},${0.3+this.breathValue*0.3})`);
            g.addColorStop(1, "rgba(0,0,0,0)");
            this.ctx.fillStyle = g; this.ctx.fill();
        }

        renderRipple() {
            const t = Date.now()*0.0005;
            for(let i=0; i<8; i++) {
                const r = (Math.min(this.width, this.height)*0.4) * ((i+1)/8) * (0.8 + this.breathValue * 0.2);
                this.ctx.beginPath();
                this.ctx.arc(this.centerX, this.centerY, r + Math.sin(t+i)*5, 0, 6.28);
                this.ctx.strokeStyle = `rgba(${this.colors.r},${this.colors.g},${this.colors.b},${0.1 + this.breathValue * 0.1})`;
                this.ctx.stroke();
            }
        }

        renderLuma() {
            // 1. Licht/Glow (Reduzierte Intensität)
            const t = Date.now() * 0.0004;
            const baseR = Math.min(this.width, this.height) * 0.20; // Kleinerer Basisradius
            const pulse = 1 + Math.sin(t) * 0.05; // Subtiles Grundrauschen
            
            // Dynamische Radien basierend auf Atemwert
            const innerR = baseR * (0.5 + this.breathValue * 0.8) * pulse; // Weniger Expansion
            const outerR = baseR * (1.0 + this.breathValue * 1.0);

            // Äußerer Glow (Aura)
            const g2 = this.ctx.createRadialGradient(this.centerX, this.centerY, 0, this.centerX, this.centerY, outerR);
            g2.addColorStop(0, `rgba(${this.colors.r}, ${this.colors.g}, ${this.colors.b}, ${0.02 * this.breathValue})`);
            g2.addColorStop(1, `rgba(${this.colors.r}, ${this.colors.g}, ${this.colors.b}, 0)`);
            
            this.ctx.fillStyle = g2;
            this.ctx.fillRect(0, 0, this.width, this.height);

            // Innerer Kern (Zentrum)
            const g1 = this.ctx.createRadialGradient(this.centerX, this.centerY, 0, this.centerX, this.centerY, innerR);
            const alpha = 0.05 + (this.breathValue * 0.1);
            g1.addColorStop(0, `rgba(${this.colors.r}, ${this.colors.g}, ${this.colors.b}, ${alpha})`);
            g1.addColorStop(0.5, `rgba(${this.colors.r}, ${this.colors.g}, ${this.colors.b}, ${alpha * 0.3})`);
            g1.addColorStop(1, `rgba(${this.colors.r}, ${this.colors.g}, ${this.colors.b}, 0)`);

            this.ctx.beginPath();
            this.ctx.arc(this.centerX, this.centerY, innerR, 0, Math.PI * 2);
            this.ctx.fillStyle = g1;
            this.ctx.fill();
            
            // 2. Mandala Overlay (Integriert)
            const t2 = Date.now() * 0.0008;
            const petals = 8;
            const mInnerR = Math.min(this.width, this.height) * 0.1;
            const expansion = this.breathValue * (Math.min(this.width, this.height) * 0.2);
            
            this.ctx.save();
            this.ctx.translate(this.centerX, this.centerY);
            
            // Layer 1: Clockwise Mandala
            this.ctx.save();
            this.ctx.rotate(t2 * 0.15); 
            
            for (let i = 0; i < petals; i++) {
                const angle = (i / petals) * Math.PI * 2 + (t2 * 0.5);
                const noiseVal = this.noise.noise2D(Math.cos(angle) + t2 * 0.1, Math.sin(angle));
                
                this.ctx.beginPath();
                this.ctx.rotate((Math.PI * 2) / petals);
                
                // Die "psychedelische" Komplexität: Sub-Kurven innerhalb der Blütenblätter
                for (let a = 0; a < Math.PI * 2; a += 0.1) {
                    const r = (mInnerR + expansion) + Math.sin(a * 5 + t2 * 2) * (10 * this.breathValue);
                    const x = Math.cos(a) * r;
                    const y = Math.sin(a) * (r * 0.4); // Elliptische Streckung
                    
                    if (a === 0) this.ctx.moveTo(x, y);
                    else this.ctx.lineTo(x, y);
                }
                
                // Farbe mit leichtem Zufalls-Offset (Noise)
                const hueShift = noiseVal * 30; 
                this.ctx.strokeStyle = `rgba(${this.colors.r + hueShift}, ${this.colors.g}, ${this.colors.b + hueShift}, ${0.1 + this.breathValue * 0.2})`;
                this.ctx.lineWidth = 1.5;
                this.ctx.stroke();
            }
            this.ctx.restore();

            // Layer 2: Counter-Clockwise Sparkle Ring
            this.ctx.save();
            this.ctx.rotate(-t2 * 0.1); 
            const sparkleCount = 12;
            for(let i=0; i<sparkleCount; i++) {
                const a = (i/sparkleCount) * Math.PI * 2;
                const n = this.noise.noise2D(Math.cos(a), Math.sin(a) + t2);
                if(n > 0) {
                    const r = (mInnerR + expansion) * 1.5 + n * 20;
                    const x = Math.cos(a) * r;
                    const y = Math.sin(a) * r;
                    
                    this.ctx.beginPath();
                    this.ctx.fillStyle = `rgba(255, 255, 255, ${n * (0.1 + this.breathValue * 0.3)})`;
                    // Draw diamond shape
                    this.ctx.moveTo(x, y-3);
                    this.ctx.lineTo(x+2, y);
                    this.ctx.lineTo(x, y+3);
                    this.ctx.lineTo(x-2, y);
                    this.ctx.fill();
                }
            }
            this.ctx.restore();

            this.ctx.restore();

            // 3. Final Layer: Complexity (Center & Rands)
            
            // Center: "Singularity" - High frequency vibration
            this.ctx.save();
            this.ctx.translate(this.centerX, this.centerY);
            this.ctx.rotate(-t2 * 8.0); // Counter-rotation
            
            const coreR = mInnerR * 0.3;
            this.ctx.beginPath();
            // Draw a spiky starburst
            for (let i = 0; i < 32; i++) { 
                const a = (i / 32) * Math.PI * 2;
                // Spike length modulated by breath
                const spike = (i % 2 === 0 ? 2 : 8) * (0.5 + this.breathValue); 
                const r = coreR + spike;
                this.ctx.lineTo(Math.cos(a) * r, Math.sin(a) * r);
            }
            this.ctx.closePath();
            // Bright center
            this.ctx.fillStyle = `rgba(255, 255, 255, ${0.01 + this.breathValue * 0.08})`;
            this.ctx.fill();
            this.ctx.strokeStyle = `rgba(255, 255, 255, ${0.05 + this.breathValue * 0.05})`;
            this.ctx.lineWidth = 0.5;
            this.ctx.stroke();
            this.ctx.restore();

            // Inner Sphere: Dark, soft, complex lines
            this.ctx.save();
            // Organic drift to match surroundings
            const driftX = Math.sin(t * 3) * (4 + 8 * this.breathValue);
            const driftY = Math.cos(t * 2.5) * (4 + 8 * this.breathValue);
            this.ctx.translate(this.centerX + driftX, this.centerY + driftY);
            
            const sphereR = mInnerR * 0.5;
            
            // Faint dark core
            this.ctx.beginPath();
            this.ctx.arc(0, 0, sphereR * (0.6 + Math.sin(t*5)*0.05), 0, Math.PI*2);
            this.ctx.fillStyle = `rgba(0, 0, 0, ${0.1 * this.breathValue})`;
            this.ctx.fill();

            // Complex evolving lines
            for(let i=0; i<4; i++) {
                this.ctx.beginPath();
                this.ctx.rotate(t2 * (5.0 + i*1.5) + Math.sin(t)*0.5); 
                for(let a=0; a<=Math.PI*2; a+=0.1) {
                    const n = this.noise.noise2D(Math.cos(a) + t2 * 2, Math.sin(a) + i);
                    const r = sphereR + n * (12 * this.breathValue);
                    const x = Math.cos(a) * r;
                    const y = Math.sin(a) * (r * (0.6 + Math.sin(t2 + i)*0.3));
                    if(a===0) this.ctx.moveTo(x, y); else this.ctx.lineTo(x, y);
                }
                this.ctx.strokeStyle = `rgba(0, 0, 0, ${0.15 + this.breathValue * 0.15})`;
                this.ctx.lineWidth = 0.6;
                this.ctx.stroke();
            }
            this.ctx.restore();

            // Rands: "Etheric Field" - Noise rings/particles at the edge
            const rimR = Math.min(this.width, this.height) * 0.44;
            this.ctx.save();
            this.ctx.translate(this.centerX, this.centerY);
            
            // Layer 1: Main Field (Rotating)
            this.ctx.save();
            this.ctx.rotate(t * 0.12); 
            this.ctx.beginPath();
            for (let i = 0; i < 90; i++) {
                // Organic wobble: no straight lines
                const wobble = Math.sin(t * 2 + i * 0.1) * 0.15;
                const a = (i / 90) * Math.PI * 2 + wobble;
                const n = this.noise.noise2D(Math.cos(a) * 1.5, Math.sin(a) * 1.5 + t * 0.3);
                
                if (n > -0.2) {
                    const r = rimR + (n * 50 * this.breathValue) + (Math.sin(i * 13.1 + t) * 8);
                    const x = Math.cos(a) * r;
                    const y = Math.sin(a) * r;
                    
                    this.ctx.moveTo(x, y);
                    const size = (1.0 + n * 1.5) + (this.breathValue * 1.5);
                    this.ctx.arc(x, y, Math.max(0.5, size), 0, Math.PI*2); 
                }
            }
            this.ctx.fillStyle = `rgba(${this.colors.r}, ${this.colors.g}, ${this.colors.b}, ${0.08 + this.breathValue * 0.12})`;
            this.ctx.fill();
            this.ctx.restore();

            // Layer 2: Chaotic Sparkles (Counter-rotating)
            this.ctx.save();
            this.ctx.rotate(-t * 0.18);
            this.ctx.beginPath();
            for (let i = 0; i < 50; i++) {
                // Erratic spiritual movement
                const dance = Math.sin(t * 3 + i) * 0.3 + Math.cos(t * 5 + i * 2) * 0.1;
                const a = (i / 50) * Math.PI * 2 + dance;
                const n = this.noise.noise2D(Math.cos(a), Math.sin(a) - t * 0.5);
                
                if (n > 0.1) {
                     const r = rimR * (0.9 + n * 0.4) + (this.breathValue * 20) + Math.sin(t * 4 + i) * 5;
                     const x = Math.cos(a) * r;
                     const y = Math.sin(a) * r;
                     this.ctx.moveTo(x, y);
                     const flicker = 1.2 + Math.sin(t * 15 + i) * 0.6;
                     this.ctx.arc(x, y, Math.max(0.5, flicker), 0, Math.PI*2);
                }
            }
            this.ctx.fillStyle = `rgba(255, 255, 255, ${0.05 + this.breathValue * 0.2})`; 
            this.ctx.fill();
            this.ctx.restore();

            this.ctx.restore();
        }
    }

    /* --- AUDIO ENGINE --- */
    class GentleAudio {
        constructor() { 
            this.ctx = null; this.nodes = []; 
            this.masterGain = null;
            this.volume = parseFloat(localStorage.getItem('atem-volume')) || 0.3;
            this.audioEl = new Audio();
            this.audioEl.crossOrigin = "anonymous";
            this.audioEl.loop = true;
            this.mediaSource = null;
            this.bowlBuffer = null;
            this.waterBuffer = null;
            this.currentType = 'none';
            this.genNodes = {};
            this.reverbNode = null;
            this.musicGain = null;
        }
        async init() {
            const AC = window.AudioContext || window.webkitAudioContext;
            if (!this.ctx && AC) { 
                this.ctx = new AC();
                this.masterGain = this.ctx.createGain();
                this.masterGain.gain.value = this.volume;
                this.masterGain.connect(this.ctx.destination);
                
                this.musicGain = this.ctx.createGain();
                this.musicGain.gain.value = 0.25;
                this.musicGain.connect(this.masterGain);
                
                this.reverbNode = this.ctx.createConvolver();
                this.reverbNode.buffer = this.createReverbBuffer();
                this.reverbNode.connect(this.masterGain);
                
                this.mediaSource = this.ctx.createMediaElementSource(this.audioEl);
                this.mediaSource.connect(this.musicGain);
            }
            // Ensure running context (iOS fix)
            if (this.ctx && this.ctx.state === 'suspended') {
                await this.ctx.resume();
            }
        }
        setVolume(v) {
            this.volume = parseFloat(v); localStorage.setItem('atem-volume', this.volume);
            if(this.masterGain) this.masterGain.gain.setTargetAtTime(this.volume, this.ctx.currentTime, 0.1);
        }
        createReverbBuffer() {
            const len = this.ctx.sampleRate * 3.0;
            const buf = this.ctx.createBuffer(2, len, this.ctx.sampleRate);
            for(let c=0;c<2;c++){
                const d = buf.getChannelData(c);
                for(let i=0;i<len;i++) d[i] = (Math.random()*2-1)*Math.pow(1-i/len, 3);
            }
            return buf;
        }
        async loadBowl() {
            if(this.bowlBuffer) return;
            const file = 'e-flat-tibetan-singing-bowl-struck-38746.mp3';
            try {
                let ab;
                try {
                    const resp = await fetch(file);
                    if(!resp.ok) throw new Error('404');
                    ab = await resp.arrayBuffer();
                } catch(e) {
                    // Fallback: Versuche audio/ Ordner
                    const resp = await fetch('audio/' + file);
                    ab = await resp.arrayBuffer();
                }
                this.bowlBuffer = await this.ctx.decodeAudioData(ab);
            } catch(e) { console.warn("Bowl load failed", e); }
        }
        async loadWater() {
            if(this.waterBuffer) return;
            const file = 'flowing-water-loop-1-183953.mp3';
            try {
                let ab;
                try {
                    const resp = await fetch(file);
                    if(!resp.ok) throw new Error('404');
                    ab = await resp.arrayBuffer();
                } catch(e) {
                    const resp = await fetch('audio/' + file);
                    ab = await resp.arrayBuffer();
                }
                this.waterBuffer = await this.ctx.decodeAudioData(ab);
            } catch(e) { console.warn("Water load failed", e); }
        }
        updateGenerator(breathVal) {
            if ((this.currentType !== 'gentle' && this.currentType !== 'ambient') || !this.ctx) return;
            const t = this.ctx.currentTime;
            // Organic drift using non-repeating sine sums
            const drift = Math.sin(t * 0.2) * 4 + Math.sin(t * 0.37) * 4; 

            if (this.currentType === 'gentle') {
                // Gentle: Sine chord (F3 Major7-ish). Volume swells with breath.
                // Target gain: Soft (0.05) to Moderate (0.25) to avoid clipping 3 oscs
                const targetGain = 0.02 + (breathVal * 0.15);
                if(this.genNodes.gain) this.genNodes.gain.gain.setTargetAtTime(targetGain, t, 0.2);
                
                if(this.genNodes.oscs) {
                    this.genNodes.oscs.forEach((osc, i) => {
                        // Subtle detune drift for "human" feel
                        osc.detune.setTargetAtTime(drift * (i % 2 === 0 ? 1 : -1), t, 0.2);
                    });
                }
            } else if (this.currentType === 'ambient') {
                // Ambient: Deep Drone. Filter opens with breath.
                // Filter: 60Hz (closed) -> 280Hz (open)
                const targetFreq = 60 + (breathVal * 220);
                if(this.genNodes.filter) this.genNodes.filter.frequency.setTargetAtTime(targetFreq, t, 0.2);
                
                // Volume static or slight swell
                const targetGain = 0.08 + (breathVal * 0.04);
                if(this.genNodes.gain) this.genNodes.gain.gain.setTargetAtTime(targetGain, t, 0.2);
                // Detune is handled by initial setup + slight drift could be added here if needed
            }
        }
        triggerImpulse(pType) {
            if(!this.ctx) return;
            const t = this.ctx.currentTime;
            const osc = this.ctx.createOscillator();
            const g = this.ctx.createGain();
            osc.connect(g); g.connect(this.masterGain);
            if(this.reverbNode) g.connect(this.reverbNode);

            let f = 440;
            if(this.currentType === 'gentle') f = pType==='in' ? 698.46 : 523.25; // F5 / C5
            else f = pType==='in' ? 392.00 : 196.00; // G4 / G3

            osc.frequency.value = f; osc.type = 'sine';
            g.gain.setValueAtTime(0, t); g.gain.linearRampToValueAtTime(0.08, t+0.02);
            g.gain.exponentialRampToValueAtTime(0.001, t+2.5);
            osc.start(t); osc.stop(t+2.5);
            setTimeout(()=>{osc.disconnect();g.disconnect();}, 2600);
        }
        triggerBowl(semitones) {
            if(!this.bowlBuffer || !this.ctx) return;
            const src = this.ctx.createBufferSource();
            src.buffer = this.bowlBuffer;
            src.detune.value = semitones * 100;
            
            const g = this.ctx.createGain();
            g.gain.value = 0.25;
            src.connect(g); g.connect(this.masterGain);
            
            src.start(0);
            src.onended = () => { const i = this.nodes.indexOf(src); if(i>-1)this.nodes.splice(i,1); };
            this.nodes.push(src);
        }
        async play(type) {
            this.stop(); // Clear previous
            this.currentType = type;
            if (!this.ctx) await this.init();
            
            if (type === 'none') return;
            
            if (type === 'bowl') { await this.loadBowl(); return; }
            
            if (type === 'water') {
                await this.loadWater();
                if(!this.waterBuffer) return;
                const src = this.ctx.createBufferSource();
                src.buffer = this.waterBuffer;
                src.loop = true;
                const g = this.ctx.createGain();
                g.gain.value = 0; 
                g.gain.linearRampToValueAtTime(0.25, this.ctx.currentTime + 2.0);
                src.connect(g); g.connect(this.masterGain);
                src.start(0);
                this.nodes.push(src); this.nodes.push(g);
                return;
            }
            
            if (type === 'gentle' || type === 'ambient') {
                const master = this.ctx.createGain();
                master.connect(this.masterGain);
                master.gain.value = 0;
                // Fade in
                master.gain.linearRampToValueAtTime(0.1, this.ctx.currentTime + 2.0);
                this.nodes.push(master);
                
                this.genNodes = { gain: master, oscs: [] };

                if (type === 'gentle') {
                    // Harmonious Chord: F3 (174.61), C4 (261.63), A4 (440) -> F Major
                    // Using 174Hz (Solfeggio 'Healing') as base
                    const freqs = [174.61, 261.63, 349.23]; 
                    freqs.forEach((f, i) => {
                        const osc = this.ctx.createOscillator();
                        osc.type = 'sine'; osc.frequency.value = f;
                        osc.detune.value = (i * 5) - 5; // Spread frequencies slightly to reduce pressure
                        osc.connect(master); osc.start();
                        this.nodes.push(osc); this.genNodes.oscs.push(osc);
                    });
                } else {
                    // Ambient: Filtered Triangle Drone (C2 base)
                    const filter = this.ctx.createBiquadFilter();
                    filter.type = 'lowpass'; filter.frequency.value = 80; filter.Q.value = 0.5;
                    filter.connect(master); this.genNodes.filter = filter;
                    
                    [65.41, 98.00].forEach((f, i) => { // C2, G2
                        const osc = this.ctx.createOscillator();
                        osc.type = i === 0 ? 'sine' : 'triangle'; // Root as sine for cleaner bottom
                        osc.frequency.value = f;
                        osc.detune.value = i===0 ? -4 : 4; // Thickener
                        osc.connect(filter); osc.start();
                        this.nodes.push(osc); this.genNodes.oscs.push(osc);
                    });
                }
            } else {
                try {
                    this.audioEl.src = type;
                    // Reset to 0 for replay
                    this.audioEl.currentTime = 0;
                    await this.audioEl.play();
                } catch (e) {
                    console.warn("Audio play failed/aborted", e);
                }
            }
        }
        stop() { 
            // Cleanup oscillators and nodes
            this.nodes.forEach(n => { try{if(n.stop)n.stop();n.disconnect();}catch(e){} }); 
            this.nodes = []; 
            // Cleanup HTML Audio
            this.audioEl.pause();
        }
    }

    const quotes = [
        { id: 1, quote: "Stellt euch euren Atem als den Weg vor, der die Energie um euch herum aufnimmt und sie mit eurer eigenen Energie verbindet. Atmet aus und macht euch leer, atmet ein und füllt euer Wesen mit der Vitalität des Lebens. Visualisiert dabei, wie eure Lebenskraft zirkuliert und eure inneren Organe nährt.", source: "Nancy N. Chen", book: "Breathing Spaces [1, 2]" },
        { id: 2, quote: "In der Tonglen-Praxis atmet man zuerst ein und nimmt das Leid anderer Wesen in sich auf. Während man inhaliert, nimmt man deren Schwierigkeiten und die Ursachen ihres Kummers an. Man befreit sie dadurch symbolisch von ihrem Schmerz und den Wurzeln ihres Leidens.", source: "Shamar Rinpoche", book: "The Path to Awakening [3, 4]" },
        { id: 3, quote: "Wenn du ausatmest, stelle dir vor, dass du all dein Glück und deine positiven Umstände an andere abgibst. Dein Mitgefühl strahlt wie helles Licht aus. Dein Atem verbreitet sich überall, ähnlich wie das Spiegelbild der Sonne auf einer weiten Wasserfläche.", source: "Shamar Rinpoche", book: "The Path to Awakening [3, 4]" },
        { id: 4, quote: "Das Wesentliche im Qi Gong ist, das Herz nicht allzu sehr in den Atem zu legen, da der Atem direkt vom Bewusstsein kommt. Sobald sich das Herz regt, entsteht Atemkraft, denn die Atemtätigkeit ist ursprünglich verwandelte Herztätigkeit. Man vereinigt die innere Ruhe mit dem Rhythmus des Atems.", source: "Meister Lü Dsu (via Olvedi)", book: "Das Stille Qi Gong [5, 6]" },
        { id: 5, quote: "Der Mensch fungiert als Leiter und Transformator der universellen Lebensenergie. Zwischen Himmel und Erde entsteht ein natürlicher Fluss, in dem wir uns als Nutznießer dieses Stromes befinden. Durch die richtige Ausrichtung wird dieser Fluss intensiviert.", source: "Günther Dogan", book: "Professionelles Qi Gong [7, 8]" },
        { id: 6, quote: "Die beste Atmung im Qi Gong ist die sanfteste, am weitesten reduzierte Atmung. Dies ist nicht das Ergebnis eines Zwangs, sondern ein natürlicher Prozess der inneren Stille. Je mehr der Atem auf natürliche Weise zur Ruhe kommt, desto wirkungsvoller wird die Arbeit mit der Energie.", source: "Ulli Olvedi", book: "Das Stille Qi Gong [9]" },
        { id: 7, quote: "Höre nicht nur  mit deinen Ohren, sondern mit dem Atem. Dieser Prozess beinhaltet eine tiefe Verbindung zum eigenen Inneren, um den Körper zu erneuern. Der Atem ist das zentrale Prinzip, das Körper, Selbst und Umwelt miteinander verbindet.", source: "Nancy N. Chen", book: "Breathing Spaces [10, 11]" },
        { id: 8, quote: "In der Einfachheit der natürlichen Dinge liegen die größten Wirkkräfte. Das Atmen und die Nahrungsaufnahme sind Vorgänge, die jedes Kind beherrscht, und die in Wirklichkeit doch komplexer sind. Wir suchen im Qi Gong die grundlegende Einfachheit der Schöpfung.", source: "Günther Dogan", book: "Professionelles Qi Gong [12, 13]" },
        { id: 9, quote: "Wenn du atmest, ist es die Natur, die dich atmet. In der tiefen Praxis können Geist und Körper leer werden, bis das Innere und Äußere zu einem einheitlichen Feld verschmelzen. In diesem Zustand gibt es keinen getrennten Teil mehr – kein isoliertes Ich.", source: "Ken Cohen", book: "The Essential Qigong Training Guide [14]" },
        { id: 10, quote: "Der Atemrhythmus ist eine Funktion unseres Bewusstseins, in der Welt zu sein. Atemmuster sind anpassungsfähig und bilden eine körperliche Umgebung, die durch unsere Emotionen strukturiert wird. Heilende Atemzüge betonen das tiefe Atmen aus der Mitte des Körpers.", source: "Nancy N. Chen", book: "Breathing Spaces [15]" },
        { id: 11, quote: "Das Geheimnis des Atmens liegt in der Aufnahme von Lebenskraft aus der Luft. Die Luft ist eine der primären Quellen für unseren Organismus. Wir nutzen diesen Umstand bewusst, um unseren energetischen Zustand zu steigern und die Vitalität zu fördern.", source: "Günther Dogan", book: "Professionelles Qi Gong [16]" },
        { id: 12, quote: "Wenn du die Gelenke lockerst und die Muskeln entspannst, verbesserst du deine energetische Leitfähigkeit. Die Energie möchte immer frei fließen wie ein ungestörter Fluss. Blockaden im Geist erzeugen unweigerlich Blockaden im physischen Körper.", source: "Günther Dogan", book: "Professionelles Tai Chi Chuan [17, 18]" },
        { id: 13, quote: "Stimmen Sie Ihren Körper, Ihren Atem und Ihren Geist aufeinander ab. Sobald dieses Instrument gestimmt ist, können Sie die Feinheiten des Lebens lernen und schöne Musik machen. Ohne ein starkes Fundament im Körper kann der Geist nicht stabil bleiben.", source: "Ken Cohen", book: "The Essential Qigong Training Guide [19]" },
        { id: 14, quote: "Wenn die Stille ihren Höhepunkt erreicht hat, erzeugt sie ganz von selbst die Bewegung der Energie. Der Atem sollte dabei sehr sanft sein und niemals angestrengt wirken. In der fortgeschrittenen Übung wird die äußere Atmung immer feiner.", source: "Meister Zhi-Chang Li (via Olvedi)", book: "Das Stille Qi Gong [20, 21]" },
        { id: 15, quote: "In der buddhistischen Praxis wird der Atem als Fahrzeug für das Bewusstsein betrachtet. Wenn die Energien im Zentralkanal zusammenströmen, lösen sich grobe Geisteszustände auf. An ihre Stelle tritt das ursprüngliche Gewahrsein des klaren Lichts.", source: "Lama Thubten Yeshe (via Olvedi)", book: "Das Stille Qi Gong [22, 23]" },
        { id: 16, quote: "Ein langer Atem ist wie ein Gebirgsbach, der ohne künstliche Dämme fließt. Er sollte glatt wie feine Seide sein und nicht grob wie Sandpapier. Durch ruhiges Atmen kultivieren wir Weisheit und Vitalität im Zentrum unseres Seins.", source: "Ken Cohen", book: "The Essential Qigong Training Guide [24, 25]" },
        { id: 17, quote: "Lebenskraft stellt den Beginn jeder organischen Kausalitätskette dar und beeinflusst direkt den Fluss in unserem Körper. Die Energie folgt dabei immer der Aufmerksamkeit deines Geistes. Wo du deine Achtsamkeit hinlenkst, dort entfaltet sich die Wirkung.", source: "Günther Dogan", book: "Professionelles Qi Gong [26, 27]" },
        { id: 18, quote: "Tonglen ist die Praxis des Gebens und Nehmens auf dem Atemzug. Das Einatmen ist wie das Lindern einer Wunde, während das Ausatmen dem Verabreichen von heilender Medizin gleicht. Es ist eine Übung, die unser Herz für die Welt öffnet.", source: "Shamar Rinpoche", book: "The Path to Awakening [3, 4]" },
        { id: 19, quote: "Der Atem ist die Verbindung, der Leim zwischen Körper, Geist und Seele. Er ist das Bindeglied zwischen unserer Wahrnehmung der inneren und der äußeren Welt. Jede Sekunde unseres Lebens hängt an diesem seidenen Faden aus Luft.", source: "Mantak Chia", book: "Tao Yoga der Liebe [10, 28]" },
        { id: 20, quote: "Ein untrainierter Geist ist wie ein Sack voll kranker Medizin, der keine Heilung bringt. Nur durch Sammlung und Ruhe in der Meditation kann Klarheit erreicht werden. Die Kraft des Geistes bestimmt, wie wir die Welt erfahren.", source: "Tsong-kha-pa", book: "Lamrim Chenmo [26, 29]" },
        { id: 21, quote: "Der Atem ist die Brücke zwischen dem Sichtbaren und dem Unsichtbaren. Durch achtsames Atmen verbinden wir uns mit der primordialen Kraft der Erde und des Himmels. Diese Harmonie ist die Grundlage für jede Form der inneren Heilung.", source: "Günther Dogan", book: "Professionelles Tai Chi Chuan [30, 31]" },
        { id: 22, quote: "Wenn Atem und Gewahrsein entspannt sind, wird wahre Weisheit erlangt. Der Atem wird hauchdünn, bis das Kommen und Gehen schließlich ganz zur Ruhe kommt. In diesem Zustand löst sich die dualistische Fixierung des Geistes auf.", source: "Jigme Lingpa", book: "Yeshe Lama [32, 33]" },
        { id: 23, quote: "Die Energie eines jeden Gedankens wird im Körper gespeichert. Wer Liebe in sich trägt, wird überall auf die transformierende Kraft der Liebe stoßen. Veredle deine Absichten, damit sie deinen Pfad durch das Leben erhellen.", source: "Mantak Chia", book: "Tao Yoga der Liebe [34, 35]" },
        { id: 24, quote: "Die Lebensenergie ist für Informationen hochempfänglich und lässt sich durch bloße Intention laden. Du kannst Qualitäten in die Energie hineinlegen, allein durch deinen Wunsch und deine Vorstellungskraft. Deine Konzentration bestimmt die Wirkung der Energie.", source: "Günther Dogan", book: "Professionelles Qi Gong [36, 37]" },
        { id: 25, quote: "In der Stille des Geistes wird die ursprüngliche Natur des Herzens offenbar. Leere das Gefäß deines Geistes von allen störenden Gedanken. Das so entstehende Vakuum wird von einer kraftvollen, klaren Energie aufgefüllt werden.", source: "Mantak Chia", book: "Tao Yoga der Liebe [38, 39]" },
        { id: 26, quote: "Durch Mitgefühl und Demut öffnen wir das Tor zu unserem wahren Potenzial. Jeder Atemzug kann eine Tat der inneren Befreiung sein. Sorge zuerst dafür, dass die Kanäle deiner Lebensenergie offen und rein sind.", source: "Tsong-kha-pa", book: "Lamrim Chenmo [40]" },
        { id: 27, quote: "Körperliche Gesundheit ist kein Endzweck, sondern die Stütze für den spirituellen Pfad. Wenn das Schiff deines Körpers beschädigt ist, wird die Seele nicht weit kommen. Pflege deinen Körper mit der gleichen Sorgfalt wie einen kostbaren Diamanten.", source: "Mantak Chia", book: "Tao Yoga der Liebe [41, 42]" },
        { id: 28, quote: "Lasse dein Gewahrsein wie einen weiten Ozean sein, in dem die Wellen der Gedanken von selbst zur Ruhe kommen. Beobachte deinen Atem, ohne ihn zu verändern, und erkenne die Stille hinter der Bewegung. Dies ist der Pfad zur Gelassenheit.", source: "Namkhai Norbu", book: "The Cycle of Day and Night [43, 44]" },
        { id: 29, quote: "Jeder Atemzug erinnert uns an unsere Verbindung zum großen Ganzen. Wir sind Transformatoren der universalen Energie und Boten des Friedens. Atme ein für dich selbst und atme aus für die ganze Welt.", source: "Shamar Rinpoche", book: "The Path to Awakening [4, 45]" },
        { id: 30, quote: "Lasse den Atem einfach so sein, wie er ist, ohne Korrekturen oder Modifikationen. In diesem unkorrigierten Zustand bleibt das momentane Gewahrsein präsent und unverändert. Alles manifestiert sich als natürliche Offenheit.", source: "Namkhai Norbu", book: "The Cycle of Day and Night [44, 46]" },
        { id: 31, quote: "Das Kultivieren der Stille lässt den Geist klar werden wie einen gereinigten Spiegel. Wenn kein störender Gedanke im Geist ist, ist der Geist in seiner reinen Natur. Diese Ruhe führt in ungeahnte Höhen der inneren Erfahrung.", source: "Ulli Olvedi", book: "Das Stille Qi Gong [47, 48]" },
        { id: 32, quote: "Atme ein: Nimm das Elend der Welt in dich auf. Während du einatmest, transformiere dieses Leiden durch dein Herz. Atme aus: Denke, dass du all dein gutes Karma und Glück an Wesen überall abgibst.", source: "Shamar Rinpoche", book: "The Path to Awakening [3, 4]" },
        { id: 33, quote: "Wenn der Körper angespannt ist, kann der Atem nicht langsam oder tief sein. Der einfachste Weg, den Geist zu ändern, besteht darin, zuerst den Körper zu entspannen. Dies ist das perfekte Gegenmittel gegen den Stress des Alltags.", source: "Ken Cohen", book: "The Essential Qigong Training Guide [49]" },
        { id: 34, quote: "Stehe fest verwurzelt wie ein Baum. Wie bei einem Baum geschieht das eigentliche Wachstum anfangs unmerklich. Geduld und Ausdauer werden sich lohnen, denn in dieser Einfachheit liegen die größten Wirkkräfte.", source: "Günther Dogan", book: "Professionelles Qi Gong [7, 24]" },
        { id: 35, quote: "In unserer Zeit wird die Spanne des Lebens oft durch Sorgen und Agitation verkürzt. Viele Krankheiten verbrauchen unsere Zeit und Energie. Nur die Praxis der Achtsamkeit kann uns helfen, die kostbare Zeit sinnvoll zu nutzen.", source: "Tsong-kha-pa", book: "Lamrim Chenmo [50]" },
        { id: 36, quote: "Bodhicitta ist der Wunsch, Erleuchtung zum Wohl aller Wesen zu erlangen. Diese altruistische Absicht ist die höchste Form der geistigen Schulung. Sie verwandelt jedes Handeln und jeden Atemzug in eine Quelle des Nutzens für andere.", source: "Shamar Rinpoche", book: "The Path to Awakening [51]" },
        { id: 37, quote: "Konzentriere dich auf die weite Offenheit des äußeren Raums. Tue dies, bis es scheint, als ob sich dein Bewusstsein völlig darin auflöst. Dann wird eine Präsenz von reinem und strahlendem Licht in deinem Herzen erscheinen.", source: "Jigme Lingpa", book: "Yeshe Lama [52, 53]" },
        { id: 38, quote: "Die Qualität deiner Empfindung bestimmt die Qualität der Energie, die du erzeugst. Wenn deine Motivation gütig ist, wird die Energie emporsteigen und den höheren Genius deines Herzens und deines Geistes aufschließen.", source: "Mantak Chia", book: "Tao Yoga der Liebe [54]" },
        { id: 39, quote: "Reine, positive und gütige Gedanken fördern die Qualität der Lebenskraft sehr stark. Das ist es, was wir während des Trainings in unserem Geist halten sollten: Dass die Kraft, die uns durchfließt, eine intelligente Heilkraft ist.", source: "Günther Dogan", book: "Professionelles Qi Gong [55, 56]" },
        { id: 40, quote: "Qi Gong bietet dem Einzelnen die Möglichkeit, Geist und Körper zu kultivieren. Durch Atemübungen und Visualisierung entstehen neue Freiräume, die den Alltag transformieren. Öffne deine Sinne für das Universum, in dem du lebst.", source: "Nancy N. Chen", book: "Breathing Spaces [1, 2]" }
    ];

    class BreathApp {
        constructor() {
            this.viz = new BreathVisuals(document.getElementById('viz-canvas'));
            this.audio = new GentleAudio();
            this.isRunning = false; 
            this.abortCtrl = null;
            this.sessionDuration = 0;
            this.startTime = 0;
            this.sessionTimerInterval = null;
            this.currentPreset = "";
            this.setupUI();
            this.randomizeVisuals();
            const p1Btn = document.querySelector(`.preset-scroll .chip[onclick*="'p1'"]`);
            this.loadPreset('p1', p1Btn);
        }

        setupUI() {
            document.getElementById('startBtn').addEventListener('click', () => this.toggle());
            document.getElementById('stop-float').addEventListener('click', () => this.stop());
            
            document.addEventListener('keydown', (e) => {
                if (e.code === 'Space' || e.key === ' ') {
                    e.preventDefault();
                    const summary = document.getElementById('summary-modal');
                    if (summary.classList.contains('visible')) {
                        this.closeSummary();
                    } else {
                        this.toggle();
                    }
                }
            });

            document.getElementById('themeSelect').addEventListener('change', (e) => {
                document.body.className = e.target.value; this.viz.updateThemeColors();
            });
            document.getElementById('soundSelect').addEventListener('change', (e) => {
                if(this.isRunning) this.audio.play(e.target.value);
            });
            document.getElementById('uploadBtn').addEventListener('click', () => document.getElementById('audioFileInput').click());
            document.getElementById('audioFileInput').addEventListener('change', (e) => {
                if(e.target.files[0]) {
                    const url = URL.createObjectURL(e.target.files[0]);
                    const sel = document.getElementById('soundSelect');
                    const opt = document.createElement('option');
                    opt.value = url; opt.text = "♫ " + e.target.files[0].name; opt.selected = true;
                    sel.add(opt);
                    if(this.isRunning) this.audio.play(url);
                }
            });
            
            const volSlider = document.getElementById('vol-slider');
            volSlider.value = this.audio.volume;
            this.updateVolumeIcon(this.audio.volume);
            
            volSlider.addEventListener('input', (e) => {
                const v = parseFloat(e.target.value);
                this.audio.setVolume(v);
                this.updateVolumeIcon(v);
            }, { passive: true });

            // Pointer Events Migration (Handle & Volume)
            document.querySelector('.handle').addEventListener('pointerup', (e) => {
                e.preventDefault();
                this.toggleUI();
            });
            
            document.getElementById('vol-icon').addEventListener('pointerup', (e) => {
                e.preventDefault();
                this.toggleMute();
            });
            
            // XY Pad Logic
            const pad = document.getElementById('xy-pad');
            const handleXY = (e) => {
                const rect = pad.getBoundingClientRect();
                const clientX = e.touches ? e.touches[0].clientX : e.clientX;
                const clientY = e.touches ? e.touches[0].clientY : e.clientY;
                
                let x = (clientX - rect.left) / rect.width;
                let y = (clientY - rect.top) / rect.height;
                x = Math.max(0, Math.min(1, x));
                y = Math.max(0, Math.min(1, y));
                this.updateXY(x, y);
            };
            pad.addEventListener('pointerdown', (e) => {
                pad.setPointerCapture(e.pointerId);
                pad.addEventListener('pointermove', handleXY);
                pad.addEventListener('pointerup', () => pad.removeEventListener('pointermove', handleXY), { once: true });
                handleXY(e);
            });
        }

        updateXY(x, y) {
            const cursor = document.getElementById('xy-cursor');
            cursor.style.left = (x * 100) + '%';
            cursor.style.top = (y * 100) + '%';
            
            // Bilinear interpolation for weights
            // TL(0,0): Mist, TR(1,0): Circle, BL(0,1): Ripple, BR(1,1): Luma
            this.viz.weights = {
                mist: (1-x) * (1-y),
                circle: x * (1-y),
                ripple: (1-x) * y,
                luma: x * y
            };
            
            // Deactivate buttons if mixing
            if (x%1!==0 || y%1!==0) document.querySelectorAll('.mode-row .chip').forEach(c => c.classList.remove('active'));
        }

        randomizeVisuals() {
            const themes = ['theme-lotusabend', 'theme-dantian-gruen', 'theme-mani-glanz', 'theme-himmelblau', 'theme-goldene-ruhe', 'theme-reines-licht'];
            const randomTheme = themes[Math.floor(Math.random() * themes.length)];
            document.body.className = randomTheme;
            document.getElementById('themeSelect').value = randomTheme;
            this.viz.updateThemeColors();

            const modes = ['mist', 'circle', 'ripple', 'luma'];
            const randomMode = modes[Math.floor(Math.random() * modes.length)];
            const modeBtn = document.querySelector(`.mode-row .chip[onclick*="'${randomMode}'"]`);
            this.setVisualMode(randomMode, modeBtn);
            
            const positions = ['pos-top', 'pos-center', 'pos-bottom'];
            const randomPos = positions[Math.floor(Math.random() * positions.length)];
            const vizArea = document.getElementById('visual-area');
            vizArea.classList.remove('pos-top', 'pos-center', 'pos-bottom');
            vizArea.classList.add(randomPos);
        }

        shuffleSession() {
            this.randomizeVisuals();
            
            const opts = Array.from(document.getElementById('soundSelect').options);
            const valid = opts.filter(o => o.value !== 'none').map(o => o.value);
            const rndSound = valid[Math.floor(Math.random() * valid.length)];
            document.getElementById('soundSelect').value = rndSound;
            if(this.isRunning) this.audio.play(rndSound);

            this.setDuration(0, document.querySelector('#duration-scroll .chip:first-child'));
        }

        loadPreset(k, el) {
            const presets = { 
                p1:[5.5,5.5], p2:[4,4], p3:[4,7,8], p4:[5,5,5,5], 
                p5:[6,6], p6:[7,7], p7:[8,8], p8:[5,5] 
            };
            const v = presets[k];
            if(!v) return;
            if(el) this.currentPreset = el.innerText;

            document.getElementById('inTime').value = v[0];
            document.getElementById('holdFullTime').value = v.length>2?v[1]:0;
            document.getElementById('outTime').value = v.length>2?v[2]:v[1];
            document.getElementById('holdEmptyTime').value = v.length==4?v[3]:0;

            const soundSelect = document.getElementById('soundSelect');
            if (k === 'p8') soundSelect.value = "audio/yrrpheus_coherence.mp3";
            else if (k === 'p1') soundSelect.value = "bowl";
            else soundSelect.value = "bowl";
            
            if (this.isRunning) this.audio.play(soundSelect.value);

            document.querySelectorAll('.preset-scroll .chip').forEach(c=>c.classList.remove('active'));
            if(el) el.classList.add('active');
        }
        
        setVisualMode(mode, el) {
            let x=0, y=0;
            if(mode === 'mist') { x=0; y=0; }
            else if(mode === 'circle') { x=1; y=0; }
            else if(mode === 'ripple') { x=0; y=1; }
            else if(mode === 'luma') { x=1; y=1; }
            this.updateXY(x, y);
            
            document.querySelectorAll('.mode-row .chip').forEach(c=>c.classList.remove('active'));
            if(el) el.classList.add('active');
        }

        setDuration(min, el) {
            this.sessionDuration = parseInt(min);
            document.querySelectorAll('#duration-scroll .chip').forEach(c=>c.classList.remove('active'));
            if(el) el.classList.add('active');
        }

        toggleMute() {
            const slider = document.getElementById('vol-slider');
            if (this.audio.volume > 0) {
                this.audio.setVolume(0);
                slider.value = 0;
                this.updateVolumeIcon(0);
            } else {
                this.updateVolumeIcon(1); // Visual feedback only, user slides manually
            }
        }

        updateVolumeIcon(vol) {
            const path = document.querySelector('#vol-icon path');
            const isMuted = vol <= 0.01;
            document.getElementById('vol-icon').style.opacity = isMuted ? 0.5 : 0.9;
            if(isMuted) path.setAttribute('d', 'M16.5 12c0-1.77-1.02-3.29-2.5-4.03v2.21l2.45 2.45c.03-.2.05-.41.05-.63zm2.5 0c0 .94-.2 1.82-.54 2.64l1.51 1.51C20.63 14.91 21 13.5 21 12c0-4.28-2.99-7.86-7-8.77v2.06c2.89.86 5 3.54 5 6.71zM4.27 3L3 4.27 7.73 9H3v6h4l5 5v-6.73l4.25 4.25c-.67.52-1.42.93-2.25 1.18v2.06c1.38-.31 2.63-.95 3.69-1.81L19.73 21 21 19.73l-9-9L4.27 3zM12 4L9.91 6.09 12 8.18V4z');
            else path.setAttribute('d', 'M3 9v6h4l5 5V4L7 9H3zm13.5 3c0-1.77-1.02-3.29-2.5-4.03v8.05c1.48-.73 2.5-2.25 2.5-4.02zM14 3.23v2.06c2.89.86 5 3.54 5 6.71s-2.11 5.85-5 6.71v2.06c4.01-.91 7-4.49 7-8.77s-2.99-7.86-7-8.77z');
        }
        
        toggleMixer() {
            const el = document.getElementById('xy-pad-container');
            const btn = document.getElementById('mixer-toggle');
            const isHidden = el.style.display === 'none';
            el.style.display = isHidden ? 'flex' : 'none';
            if(isHidden) btn.classList.add('active'); else btn.classList.remove('active');
        }

        toggleUI() { document.getElementById('ui-container').classList.toggle('hidden'); }
        closeSummary() { document.getElementById('summary-modal').classList.remove('visible'); }
        
        async toggle() { this.isRunning ? this.stop() : this.start(); }

        async start() {
            if (this.isRunning) return;
            
            const btn = document.getElementById('startBtn');
            const oldText = btn.innerText;
            btn.innerText = "Laden...";
            btn.disabled = true;

            try {
                // Audio init & WakeLock
                await this.audio.init();
                await this.audio.play(document.getElementById('soundSelect').value);
                if(navigator.wakeLock) try { this.wakelock = await navigator.wakeLock.request('screen'); } catch(e){}

                this.isRunning = true;
                this.startTime = Date.now();
                
                document.getElementById('ui-container').classList.add('hidden');
                document.body.classList.add('ui-hidden');
                document.getElementById('summary-modal').classList.remove('visible');
                btn.innerText = "Beenden";
                btn.classList.add('stop-mode');
                btn.disabled = false;
                document.getElementById('stop-float').style.display = 'block';
                
                document.getElementById('preset-display').innerText = this.currentPreset || "Freies Atmen";
                document.getElementById('preset-display').classList.add('visible');
                
                // Cleanup old controller if exists
                if(this.abortCtrl) this.abortCtrl.abort();
                this.abortCtrl = new AbortController();
                
                this.loop(this.abortCtrl.signal);

                document.getElementById('session-timer').classList.add('visible');
                this.updateSessionTimer();
                // Clear any existing interval
                if(this.sessionTimerInterval) clearInterval(this.sessionTimerInterval);
                this.sessionTimerInterval = setInterval(() => this.updateSessionTimer(), 1000);
                
            } catch (err) {
                console.error(err);
                this.isRunning = false;
                btn.innerText = oldText;
                btn.disabled = false;
            }
        }

        getUniqueQuote() {
            let history = [];
            try { history = JSON.parse(localStorage.getItem('atem-quote-history')) || []; } catch(e){}
            
            let candidates = quotes.filter(q => !history.includes(q.id));
            if (candidates.length === 0) { candidates = quotes; history = []; }
            
            const q = candidates[Math.floor(Math.random() * candidates.length)];
            
            history.push(q.id);
            if (history.length > 30) history.shift();
            localStorage.setItem('atem-quote-history', JSON.stringify(history));
            return q;
        }

        stop() {
            this.isRunning = false;
            if(this.abortCtrl) { this.abortCtrl.abort(); this.abortCtrl = null; }
            this.audio.stop();
            if(this.sessionTimerInterval) clearInterval(this.sessionTimerInterval);
            document.getElementById('session-timer').classList.remove('visible');
            document.getElementById('preset-display').classList.remove('visible');

            if(this.wakelock) this.wakelock.release();
            
            document.getElementById('ui-container').classList.remove('hidden');
            document.body.classList.remove('ui-hidden');
            document.getElementById('startBtn').innerText = "Beginnen";
            document.getElementById('startBtn').classList.remove('stop-mode');
            document.getElementById('stop-float').style.display = 'none';
            
            const instr = document.getElementById('instruction');
            instr.innerText = "Atmen";
            instr.style.color = '';
            document.getElementById('breath-timer').innerText = "";
            this.viz.setBreathState(0.5, 'hold-empty');
            
            const elapsedSec = Math.floor((Date.now() - this.startTime) / 1000);
            
            if (elapsedSec >= 30) {
                const m = Math.floor(elapsedSec / 60);
                const s = elapsedSec % 60;
                document.getElementById('summary-time').innerText = `${m} Minuten und ${s} Sekunden`;

                const q = this.getUniqueQuote();
                document.getElementById('quote-text').innerText = q.quote;
                document.getElementById('quote-author').innerText = q.source;
                document.getElementById('summary-modal').classList.add('visible');
            }
        }

        updateSessionTimer() {
            const elapsed = Date.now() - this.startTime;
            if (this.sessionDuration > 0) {
                const totalMs = this.sessionDuration * 60 * 1000;
                const remaining = Math.max(0, totalMs - elapsed);
                const m = Math.floor(remaining / 60000);
                const s = Math.floor((remaining % 60000) / 1000);
                document.getElementById('session-timer').innerText = `${m.toString().padStart(2, '0')}:${s.toString().padStart(2, '0')}`;
                if (remaining <= 0) this.stop();
            } else {
                const m = Math.floor(elapsed / 60000);
                const s = Math.floor((elapsed % 60000) / 1000);
                document.getElementById('session-timer').innerText = `${m.toString().padStart(2, '0')}:${s.toString().padStart(2, '0')}`;
            }
        }

        async loop(signal) {
            const val = id => parseFloat(document.getElementById(id).value) || 0;
            // The isRunning check here ensures we don't start a new loop if stop() was called during a phase transition
            while(!signal.aborted && this.isRunning) {
                await this.phase("Einatmen", val('inTime'), 0, 1, '#82B1FF', signal, true);
                await this.phase("Halten", val('holdFullTime'), 1, 1, '#D1D1D1', signal, false);
                await this.phase("Ausatmen", val('outTime'), 1, 0, '#EF9A9A', signal, false);
                await this.phase("Pause", val('holdEmptyTime'), 0, 0, '#D1D1D1', signal, false);
            }
        }
        
        async phase(text, dur, startV, endV, col, signal, countUp) {
            if(signal.aborted || !this.isRunning || dur <= 0) return;
            
            const instr = document.getElementById('instruction');
            instr.innerText = text;
            instr.style.color = col;
            
            let pType = 'hold-empty';
            if (startV < endV) pType = 'in';
            else if (startV > endV) pType = 'out';
            else if (startV === 1) pType = 'hold-full';
            
            document.getElementById('breath-timer').setAttribute('data-phase', pType);
            
            if (this.audio.currentType === 'bowl') {
                if (pType === 'in') this.audio.triggerBowl(0);
                else if (pType === 'out') this.audio.triggerBowl(-5);
            } else if (this.audio.currentType === 'gentle' || this.audio.currentType === 'ambient') {
                if (pType === 'in' || pType === 'out') this.audio.triggerImpulse(pType);
            }
            
            const start = Date.now();
            return new Promise(resolve => {
                const tick = () => {
                    if(signal.aborted || !this.isRunning) return resolve();
                    
                    const now = Date.now();
                    const prog = Math.min(1, (now - start)/(dur*1000));
                    const eased = 0.5 * (1 - Math.cos(Math.PI * prog)); 
                    const currentBreath = startV + (endV - startV) * eased;
                    
                    this.viz.setBreathState(currentBreath, pType);
                    this.audio.updateGenerator(currentBreath);
                    
                    const timeVal = countUp ? (dur * prog) : (dur - (dur * prog));
                    const timer = document.getElementById('breath-timer');
                    timer.innerText = timeVal.toFixed(0); 
                    timer.style.color = col;
                    
                    if(prog < 1) requestAnimationFrame(tick); else resolve();
                };
                tick();
            });
        }
    }

    document.addEventListener('DOMContentLoaded', () => window.app = new BreathApp());
    </script>
</body>
</html>
