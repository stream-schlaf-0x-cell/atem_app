<!-- START OF FILE Paste January 31, 2026 - Optimized -->
<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="theme-color" content="#0a0a0a">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>Atem & Stille</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Forum&family=Tenor+Sans&display=swap" rel="stylesheet">
    <style>
        /* --- CSS STYLES --- */
        :root {
            --bg-color: #0a0a0a; --text-color: #efece6;
            --accent-primary: #4a638c; --accent-secondary: #e6c65a;
            --glass-bg: rgba(10, 10, 10, 0.65);
            --font-stack: 'Tenor Sans', 'Forum', 'Optima', 'Segoe UI Light', sans-serif;
            --safe-top: env(safe-area-inset-top, 20px);
            --safe-bottom: env(safe-area-inset-bottom, 20px);
        }
        * { box-sizing: border-box; -webkit-tap-highlight-color: transparent; }
        body {
            background-color: var(--bg-color); color: var(--text-color);
            font-family: var(--font-stack); margin: 0; height: 100dvh;
            display: flex; flex-direction: column; overflow: hidden;
            transition: background-color 2s ease; 
            overscroll-behavior: none; touch-action: none; /* iOS Scroll Fix */
        }
        /* THEMES */
        body.theme-himmelblau { --bg-color: #0b1026; --accent-primary: #6b8c96; --glass-bg: rgba(11, 16, 38, 0.65); }
        body.theme-goldene-ruhe { --bg-color: #120c08; --accent-primary: #ba9655; --glass-bg: rgba(18, 12, 8, 0.65); }
        body.theme-lotusabend { --bg-color: #0e0b0c; --accent-primary: #a65959; --glass-bg: rgba(10,8,9,0.55); }
        body.theme-dantian-gruen { --bg-color: #071012; --accent-primary: #5d7a66; --glass-bg: rgba(8,12,10,0.56); }
        body.theme-reines-licht { --bg-color: #121212; --accent-primary: #cfd8dc; --glass-bg: rgba(18, 18, 18, 0.65); }
        body.theme-mani-glanz { --bg-color: #070709; --accent-primary: #5e7291; --glass-bg: rgba(6,6,6,0.58); }
        
        /* LAYOUT */
        #visual-area { flex-grow: 1; display: flex; flex-direction: column; align-items: center; justify-content: center; position: relative; width: 100%; height: 100%; touch-action: none; }
        .viz-canvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; display: block; touch-action: none; }
        
        .instruction-text {
            position: fixed; left: 50%; transform: translateX(-50%); top: calc(var(--safe-top) + 12px);
            font-size: 1.5rem; font-weight: 300; letter-spacing: 0.1em; padding: 6px 12px; border-radius: 12px;
            pointer-events: none; opacity: 0.95; color: var(--text-color); 
            background: linear-gradient(180deg, rgba(0,0,0,0.04), rgba(255,255,255,0.02));
            z-index: 100; will-change: transform, opacity; transition: opacity 0.5s ease, color 0.8s ease;
        }
        #breath-timer {
            position: fixed; left: 50%; transform: translateX(-50%); top: calc(var(--safe-top) + 56px);
            font-size: 1.8rem; font-weight: 300; letter-spacing: 0.1em; color: var(--accent-secondary); background: rgba(0,0,0,0.18);
            padding: 6px 12px; border-radius: 14px; pointer-events: none; z-index: 110;
            font-variant-numeric: tabular-nums; transition: opacity 0.5s ease;
        }

        #ui-container {
            position: absolute; bottom: 0; width: 100%; background: var(--glass-bg);
            backdrop-filter: blur(15px); -webkit-backdrop-filter: blur(15px);
            border-top: 1px solid rgba(255,255,255,0.03); border-radius: 20px 20px 0 0;
            padding: 8px 20px calc(15px + var(--safe-bottom));
            transform: translateY(0); transition: transform 0.8s cubic-bezier(0.2, 0.8, 0.2, 1);
            z-index: 1000; will-change: transform;
        }
        #ui-container.hidden { transform: translateY(110%); }

        .handle { width: 35px; height: 3px; background: rgba(255,255,255,0.08); border-radius: 10px; margin: 10px auto 20px; cursor: pointer; }
        .preset-scroll { display: flex; gap: 8px; overflow-x: auto; padding-bottom: 12px; margin-bottom: 12px; scrollbar-width: none; mask-image: linear-gradient(to right, black 90%, transparent 100%); -webkit-mask-image: linear-gradient(to right, black 90%, transparent 100%); }
        .preset-scroll::-webkit-scrollbar { display: none; }

        .chip { background: rgba(255,255,255,0.03); border: 1px solid rgba(255,255,255,0.05); color: rgba(255,255,255,0.5); padding: 7px 14px; border-radius: 18px; font-size: 0.85rem; white-space: nowrap; cursor: pointer; transition: all 0.4s; -webkit-tap-highlight-color: transparent; }
        .chip.active { background: rgba(255,255,255,0.08); color: var(--accent-primary); border-color: rgba(200, 200, 200, 0.1); }
        
        #duration-scroll input { width: 60px; background: rgba(255,255,255,0.03); border: 1px solid rgba(255,255,255,0.05); color: var(--text-color); padding: 7px; border-radius: 18px; font-size: 0.85rem; text-align: center; transition: all 0.4s; }
        #duration-scroll input:focus { border-color: var(--accent-primary); background: rgba(255,255,255,0.08); }

        .controls-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 12px; margin-bottom: 16px; }
        label { font-size: 0.7rem; text-transform: uppercase; font-weight: 500; color: rgba(255,255,255,0.25); margin-bottom: 5px; display: block; }
        input, select { width: 100%; background: rgba(0,0,0,0.15); border: 1px solid rgba(255,255,255,0.05); color: var(--text-color); padding: 10px; border-radius: 10px; font-size: 1.05rem; outline: none; appearance: none; }

        .btn { background: linear-gradient(135deg, var(--accent-primary), var(--accent-secondary)); color: #fff; border: none; padding: 16px; border-radius: 14px; font-size: 1.05rem; font-weight: 500; width: 100%; text-transform: uppercase; cursor: pointer; transition: transform 0.15s; user-select: none; }
        .btn:active { transform: scale(0.985); }
        .btn.stop-mode { background: var(--accent-primary); opacity: 0.9; }

        .mode-row { display: flex; gap: 8px; margin-bottom: 20px; justify-content: center; }

        /* Summary Overlay */
        #summary-modal { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(10, 10, 10, 0.92); backdrop-filter: blur(15px); display: flex; flex-direction: column; justify-content: center; align-items: center; z-index: 1100; padding: 30px; text-align: center; opacity: 0; pointer-events: none; transition: opacity 0.6s; }
        #summary-modal.visible { opacity: 1; pointer-events: all; }
        .summary-stat { font-size: 3.8rem; font-weight: 100; color: var(--accent-primary); margin: 15px 0; font-variant-numeric: tabular-nums; }
        .summary-quote { font-size: 1.4rem; opacity: 0.85; line-height: 1.4; margin: 20px auto 10px; max-width: 500px; }
        .summary-author { font-size: 1.05rem; opacity: 0.65; margin: 5px auto 0; }

        /* VOLUME CONTROL */
        #volume-control { position: fixed; top: calc(var(--safe-top) + 20px); right: 20px; display: flex; align-items: center; gap: 12px; background: rgba(0,0,0,0.2); backdrop-filter: blur(10px); -webkit-backdrop-filter: blur(10px); padding: 8px 14px; border-radius: 20px; border: 1px solid rgba(255,255,255,0.05); transition: background 0.3s ease; z-index: 250; width: auto; }
        #volume-control:hover { background: rgba(0,0,0,0.4); }
        #vol-icon { width: 24px; height: 24px; fill: var(--text-color); opacity: 0.6; cursor: pointer; flex-shrink: 0; transition: opacity 0.2s; -webkit-tap-highlight-color: transparent; }
        #vol-slider { width: 80px; height: 2px; -webkit-appearance: none; background: rgba(255,255,255,0.15); border-radius: 2px; outline: none; opacity: 1; }
        #vol-slider::-webkit-slider-thumb { -webkit-appearance: none; width: 10px; height: 10px; border-radius: 50%; background: var(--accent-primary); cursor: pointer; transition: transform 0.1s; }
        #vol-slider::-webkit-slider-thumb:active { transform: scale(1.3); }

        /* BOTTOM CONTROLS (Refresh & Timer) */
        #bottom-controls {
            position: fixed; bottom: calc(var(--safe-bottom) + 20px); right: 20px;
            display: flex; align-items: center; gap: 12px; z-index: 240;
            pointer-events: none; /* Allow clicks to pass through empty areas */
        }
        
        #menu-shuffle-btn {
            position: absolute; top: 15px; right: 20px;
            width: 44px; height: 44px; border-radius: 50%;
            background: rgba(255,255,255,0.05); border: 1px solid rgba(255,255,255,0.1);
            display: flex; align-items: center; justify-content: center;
            cursor: pointer; transition: all 0.3s ease; z-index: 20;
            color: var(--text-color); opacity: 0.6;
        }
        #menu-shuffle-btn:hover { background: rgba(255,255,255,0.15); opacity: 1; transform: scale(1.05); }
        #menu-shuffle-btn svg { width: 24px; height: 24px; fill: currentColor; }

        #session-timer { 
            position: static; /* Flex item */
            font-size: 1.1rem; font-weight: 400; color: var(--text-color); font-variant-numeric: tabular-nums;
            opacity: 0; max-width: 0; padding: 0; overflow: hidden; white-space: nowrap;
            transition: all 0.6s cubic-bezier(0.2, 0.8, 0.2, 1); pointer-events: none; 
            background: rgba(0,0,0,0.18); backdrop-filter: blur(10px); -webkit-backdrop-filter: blur(10px);
            border-radius: 14px;
        }
        #session-timer.visible { opacity: 0.8; max-width: 100px; padding: 6px 12px; pointer-events: auto; }
        #session-timer:hover { opacity: 1; }
        
        #preset-display {
            position: fixed; bottom: 35px; left: calc(50% + 125px); transform: none;
            font-size: 1.05rem; letter-spacing: 0.1em; color: rgba(255,255,255,0.9);
            background: rgba(0,0,0,0.2); backdrop-filter: blur(10px); -webkit-backdrop-filter: blur(10px);
            padding: 8px 16px; border-radius: 16px; border: 1px solid rgba(255,255,255,0.1);
            pointer-events: none; opacity: 0; transition: opacity 0.5s; z-index: 190;
            text-transform: uppercase; font-weight: 500; font-family: sans-serif;
        }
        #preset-display.visible { opacity: 1; }

        /* TEXT POSITIONS */
        .pos-top .instruction-text { top: calc(var(--safe-top) + 12px); bottom: auto; transform: translateX(-50%); }
        .pos-top #breath-timer { top: calc(var(--safe-top) + 56px); bottom: auto; transform: translateX(-50%); }

        .pos-center .instruction-text { top: 46%; bottom: auto; transform: translate(-50%, -50%); }
        .pos-center #breath-timer { top: 54%; bottom: auto; transform: translate(-50%, -50%); }

        .pos-bottom .instruction-text { top: auto; bottom: 140px; transform: translateX(-50%); }
        .pos-bottom #breath-timer { top: auto; bottom: 95px; transform: translateX(-50%); }

        /* Hide text when UI is visible */
        body:not(.ui-hidden) .instruction-text, body:not(.ui-hidden) #breath-timer {
            opacity: 0 !important;
            pointer-events: none;
        }

        /* DESKTOP TWEAKS (Keep iPad/Mobile as is) */
        @media (min-width: 1025px) {
            #ui-container { 
                max-width: 640px; left: 50%; bottom: 40px; transform: translateX(-50%); 
                border-radius: 24px; 
            }
            #ui-container.hidden { transform: translate(-50%, 130%); }
            
            .controls-grid { gap: 12px; margin-bottom: 16px; }
            input, select, .btn { padding: 12px; font-size: 1rem; }
            
            .preset-scroll { flex-wrap: wrap; justify-content: center; overflow: visible; }
        }
    </style>
</head>
<body class="theme-lotusabend">

    <div id="visual-area">
        <canvas id="viz-canvas" class="viz-canvas"></canvas>
        <div class="instruction-text" id="instruction">Atmen</div>
        <div id="breath-timer"></div>
        <div id="preset-display"></div>
        <div id="bottom-controls">
            <div id="session-timer"></div>
        </div>
        <div id="volume-control">
            <svg id="vol-icon" viewBox="0 0 24 24" onclick="app.toggleMute()"><path d="M3 9v6h4l5 5V4L7 9H3zm13.5 3c0-1.77-1.02-3.29-2.5-4.03v8.05c1.48-.73 2.5-2.25 2.5-4.02zM14 3.23v2.06c2.89.86 5 3.54 5 6.71s-2.11 5.85-5 6.71v2.06c4.01-.91 7-4.49 7-8.77s-2.99-7.86-7-8.77z"/></svg>
            <input type="range" id="vol-slider" min="0" max="1" step="0.01">
        </div>
    </div>

    <div id="summary-modal">
        <h2 style="font-weight: 100; opacity: 0.5; font-size: 1.8rem;">Breathwork abgeschlossen</h2>
        <div id="summary-time" class="summary-stat">0m</div>
        <p class="summary-quote" id="quote-text"></p>
        <div id="quote-author" class="summary-author"></div>
        <button class="btn" style="margin-top: 30px; width: auto; padding: 12px 35px;" onclick="app.closeSummary()">Schließen</button>
    </div>

    <div id="ui-container">
        <div class="handle" onclick="app.toggleUI()"></div>
        <div id="menu-shuffle-btn" onclick="app.shuffleSession()" role="button" aria-label="Zufällig">
            <svg viewBox="0 0 24 24"><path d="M10.59 9.17L5.41 4 4 5.41l5.17 5.17 1.42-1.41zM14.5 4l2.04 2.04L4 18.59 5.41 20 17.96 7.46 20 9.5V4h-5.5zM14.83 13.41l-1.41 1.41 3.13 3.13L14.5 20H20v-5.5l-2.04 2.04L14.83 13.41z"/></svg>
        </div>

        <div class="mode-row">
            <button class="chip active" onclick="app.setVisualMode('mist', this)">Nebel</button>
            <button class="chip" onclick="app.setVisualMode('circle', this)">Kreis</button>
            <button class="chip" onclick="app.setVisualMode('ripple', this)">Welle</button>
        </div>

        <label style="margin-left: 5px;">Presets</label>
        <div class="preset-scroll">
            <button class="chip" onclick="app.loadPreset('p1', this)">5.5 : 5.5</button>
            <button class="chip" onclick="app.loadPreset('p2', this)">4 : 4</button>
            <button class="chip" onclick="app.loadPreset('p8', this)">5 : 5</button>
            <button class="chip" onclick="app.loadPreset('p3', this)">4 : 7 : 8</button>
            <button class="chip" onclick="app.loadPreset('p4', this)">5 : 5 : 5 : 5</button>
            <button class="chip" onclick="app.loadPreset('p5', this)">6 : 6</button>
            <button class="chip" onclick="app.loadPreset('p6', this)">7 : 7</button>
            <button class="chip" onclick="app.loadPreset('p7', this)">8 : 8</button>
        </div>

        <div class="controls-grid">
            <div><label>Einatmen</label><input type="number" id="inTime" value="5.5" min="2" step="0.5"></div>
            <div><label>Ausatmen</label><input type="number" id="outTime" value="5.5" min="2" step="0.5"></div>
            <div><label>Halten (voll)</label><input type="number" id="holdFullTime" value="0" min="0" step="1"></div>
            <div><label>Pause (leer)</label><input type="number" id="holdEmptyTime" value="0" min="0" step="1"></div>
        </div>

        <div class="controls-grid">
            <div>
                <label>Atmosphäre</label>
                <select id="themeSelect">
                    <option value="theme-lotusabend">Lotusabend</option>
                    <option value="theme-dantian-gruen">Dantian‑Grün</option>
                    <option value="theme-mani-glanz">Mani‑Glanz</option>
                    <option value="theme-himmelblau">Himmelblau</option>
                    <option value="theme-goldene-ruhe">Goldene Ruhe</option>
                    <option value="theme-reines-licht">Reines Licht</option>
                </select>
            </div>
            <div>
                <label>Audio / Musik</label>
                <div style="display:flex; gap:8px; align-items:center;">
                    <select id="soundSelect" style="flex:1;">
                        <option value="none">Stille</option>
                        <option value="gentle">Generator: Sanft</option>
                        <option value="ambient">Generator: Ambient</option>
                        <option value="bowl">Tibetische Klangschale</option>
                        <option value="water">Fließendes Wasser</option>
                        <option value="audio/accede_atem_track-5_5.mp3">Accede: Atem Track (5.5)</option>
                        <option value="audio/altus_session3.mp3">Altus: Session 3 (5.5)</option>
                        <option value="audio/yrrpheus_coherence.mp3">Yrrpheus: Coherence</option>
                    </select>
                    <input type="file" id="audioFileInput" accept="audio/*" style="display:none">
                    <button class="btn" id="uploadBtn" style="width:auto; padding:8px 10px;">+</button>
                </div>
            </div>
        </div>

        <label>Sitzungsdauer (Minuten)</label>
        <div class="preset-scroll" id="duration-scroll">
            <button class="chip active" onclick="app.setDuration(0, this)">∞ (Endlos)</button>
            <button class="chip" onclick="app.setDuration(3, this)">3</button>
            <button class="chip" onclick="app.setDuration(5, this)">5</button>
            <button class="chip" onclick="app.setDuration(10, this)">10</button>
            <button class="chip" onclick="app.setDuration(15, this)">15</button>
            <button class="chip" onclick="app.setDuration(20, this)">20</button>
            <button class="chip" onclick="app.setDuration(25, this)">25</button>
            <button class="chip" onclick="app.setDuration(30, this)">30</button>
            <input type="number" placeholder="Min" onchange="app.setDuration(this.value, null)">
        </div>

        <button class="btn" id="startBtn">Beginnen</button>
    </div>

    <button id="stop-float" class="btn stop-mode" style="display:none; position:fixed; left:50%; transform:translateX(-50%); bottom:26px; z-index:200; width:220px; box-shadow: 0 4px 15px rgba(0,0,0,0.3);">Beenden</button>

    <script>
    // Optimized Simplex Noise with Zero Allocation per Call
    const GRAD3 = [[1,1],[-1,1],[1,-1],[-1,-1],[1,0],[-1,0],[1,0],[-1,0],[0,1],[0,-1],[0,1],[0,-1]];
    class SimplexNoise { 
        constructor() {
            this.p = new Uint8Array(256);
            for(let i=0;i<256;i++) this.p[i]=i;
            for(let i=0;i<256;i++) {
                let r = Math.random()*256|0, t = this.p[i];
                this.p[i] = this.p[r]; this.p[r] = t;
            }
            this.perm = new Uint8Array(512);
            for(let i=0;i<512;i++) this.perm[i] = this.p[i&255];
        }
        noise2D(x, y) {
            const F2 = 0.5*(Math.sqrt(3.0)-1.0), G2 = (3.0-Math.sqrt(3.0))/6.0;
            let s = (x+y)*F2, i = Math.floor(x+s), j = Math.floor(y+s);
            let t = (i+j)*G2, X0 = i-t, Y0 = j-t, x0 = x-X0, y0 = y-Y0;
            let i1 = x0>y0 ? 1 : 0, j1 = x0>y0 ? 0 : 1;
            let x1 = x0 - i1 + G2, y1 = y0 - j1 + G2;
            let x2 = x0 - 1.0 + 2.0*G2, y2 = y0 - 1.0 + 2.0*G2;
            let ii = i&255, jj = j&255;
            let gi0 = this.perm[ii+this.perm[jj]]%12, gi1 = this.perm[ii+i1+this.perm[jj+j1]]%12, gi2 = this.perm[ii+1+this.perm[jj+1]]%12;
            let t0 = 0.5 - x0*x0 - y0*y0, n0 = t0<0 ? 0 : t0*t0 * (GRAD3[gi0][0]*x0 + GRAD3[gi0][1]*y0);
            let t1 = 0.5 - x1*x1 - y1*y1, n1 = t1<0 ? 0 : t1*t1 * (GRAD3[gi1][0]*x1 + GRAD3[gi1][1]*y1);
            let t2 = 0.5 - x2*x2 - y2*y2, n2 = t2<0 ? 0 : t2*t2 * (GRAD3[gi2][0]*x2 + GRAD3[gi2][1]*y2);
            return 70.0 * (n0 + n1 + n2);
        }
    }

    class BreathVisuals {
        constructor(canvas) {
            this.canvas = canvas; this.ctx = this.canvas.getContext('2d', { alpha: false, desynchronized: true });
            this.noise = new SimplexNoise(); 
            this.dpr = Math.min(window.devicePixelRatio || 1, 2);
            this.width = 0; this.height = 0; this.centerX = 0; this.centerY = 0;
            this.mode = 'mist'; this.breathValue = 0.5; this.colors = { r:138, g:138, b:138 };
            
            // Optimization: Structure of Arrays (SoA) for zero-GC particles
            this.pCount = 500;
            this.p_x = new Float32Array(this.pCount);
            this.p_y = new Float32Array(this.pCount);
            this.p_vx = new Float32Array(this.pCount);
            this.p_vy = new Float32Array(this.pCount);
            this.p_life = new Float32Array(this.pCount);
            this.p_maxLife = new Float32Array(this.pCount);
            this.p_size = new Float32Array(this.pCount);
            this.p_baseAlpha = new Float32Array(this.pCount);
            
            this.particleSprite = null;
            this.phase = 'hold-empty';
            this.initParticles = false;
            
            window.addEventListener('resize', () => this.resize(), { passive: true }); 
            this.resize(); 
            this.animate();
        }

        updateThemeColors() {
            const style = getComputedStyle(document.body);
            const hex = (style.getPropertyValue('--accent-primary') || '#8a8a8a').trim().replace('#', '');
            if (hex.length === 6) {
                const bi = parseInt(hex, 16); this.colors = { r: (bi >> 16) & 255, g: (bi >> 8) & 255, b: bi & 255 };
            }
            this.generateSprite();
        }

        generateSprite() {
            this.particleSprite = document.createElement('canvas');
            const s = 64; this.particleSprite.width = s; this.particleSprite.height = s;
            const ctx = this.particleSprite.getContext('2d');
            const g = ctx.createRadialGradient(s/2, s/2, 0, s/2, s/2, s/2);
            g.addColorStop(0, `rgba(${this.colors.r},${this.colors.g},${this.colors.b},1)`);
            g.addColorStop(1, `rgba(${this.colors.r},${this.colors.g},${this.colors.b},0)`);
            ctx.fillStyle = g; ctx.fillRect(0, 0, s, s);
        }

        resize() {
            const rect = this.canvas.parentElement.getBoundingClientRect();
            this.width = rect.width; this.height = rect.height;
            this.canvas.width = this.width * this.dpr; this.canvas.height = this.height * this.dpr;
            this.canvas.style.width = this.width + 'px'; this.canvas.style.height = this.height + 'px';
            this.ctx.setTransform(this.dpr, 0, 0, this.dpr, 0, 0);
            this.centerX = this.width / 2; this.centerY = this.height / 2;
            this.updateThemeColors(); 
            this.initParticles = false; // Trigger reset
        }

        setBreathState(v, p) { 
            this.breathValue = Math.max(0, Math.min(1, v)); 
            this.phase = p;
        }
        
        animate() {
            requestAnimationFrame(() => this.animate());
            
            // Clear / Fade
            const fade = this.mode === 'mist' ? 0.12 : 0.025;
            this.ctx.globalCompositeOperation = 'source-over';
            // Cache BG Color would be better, but css variable might change
            const bgStr = getComputedStyle(document.body).getPropertyValue('--bg-color').trim();
            const r = parseInt(bgStr.slice(1,3),16), g = parseInt(bgStr.slice(3,5),16), b = parseInt(bgStr.slice(5,7),16);
            this.ctx.fillStyle = `rgba(${r}, ${g}, ${b}, ${fade})`;
            this.ctx.fillRect(0, 0, this.width, this.height);
            this.ctx.globalCompositeOperation = 'lighter';

            if (this.mode === 'mist') this.renderMist();
            else if (this.mode === 'circle') this.renderCircle();
            else if (this.mode === 'ripple') this.renderRipple();
        }

        resetParticle(i) {
            this.p_x[i] = Math.random() * this.width;
            this.p_y[i] = Math.random() * this.height;
            this.p_vx[i] = 0; 
            this.p_vy[i] = 0;
            this.p_life[i] = 0; 
            this.p_maxLife[i] = 150 + Math.random() * 250;
            this.p_size[i] = (4 + Math.random() * 24) * (this.dpr * 0.6);
            this.p_baseAlpha[i] = 0.05 + Math.random() * 0.25;
        }

        renderMist() {
            if (!this.initParticles) {
                for (let i = 0; i < this.pCount; i++) this.resetParticle(i);
                this.initParticles = true;
            }

            const time = Date.now() * 0.0003;
            const center = { x: this.centerX, y: this.centerY };
            const maxR = Math.min(this.width, this.height) * 0.4;
            const targetR = 20 + (maxR * this.breathValue);

            let turbulence = 0.03;
            if (this.phase === 'hold-full') turbulence = 0.05;
            else if (this.phase === 'hold-empty') turbulence = 0.01;

            const noiseScale = 0.0015;

            for (let i = 0; i < this.pCount; i++) {
                this.p_life[i]++;
                if (this.p_life[i] > this.p_maxLife[i]) this.resetParticle(i);

                // Noise lookup - heavily optimized
                const n = this.noise.noise2D(this.p_x[i] * noiseScale, this.p_y[i] * noiseScale + time);
                const angle = n * 12.56; // 4 * PI
                
                this.p_vx[i] += Math.cos(angle) * turbulence;
                this.p_vy[i] += Math.sin(angle) * turbulence;

                const dx = this.p_x[i] - center.x;
                const dy = this.p_y[i] - center.y;
                const distSq = dx*dx + dy*dy;
                const dist = Math.sqrt(distSq); // Needed for linear force logic
                
                // Avoid division by zero
                const invDist = dist > 0.1 ? 1.0 / dist : 0;
                const dirX = dx * invDist;
                const dirY = dy * invDist;

                let force = 0;
                if (this.phase === 'in') {
                    force = (targetR - dist) * 0.0005; 
                    if (dist < targetR * 0.5) force += 0.002;
                } else if (this.phase === 'out') {
                    force = (targetR - dist) * 0.0008;
                } else if (this.phase === 'hold-full') {
                    force = (targetR - dist) * 0.001;
                } else {
                    force = (targetR - dist) * 0.0005;
                }

                this.p_vx[i] += dirX * force;
                this.p_vy[i] += dirY * force;
                
                this.p_vx[i] *= 0.92; 
                this.p_vy[i] *= 0.92;
                this.p_x[i] += this.p_vx[i]; 
                this.p_y[i] += this.p_vy[i];

                const lifeProg = this.p_life[i] / this.p_maxLife[i];
                let alphaMult = 0.5 + this.breathValue * 0.5;
                if (this.phase === 'out') alphaMult *= 0.8;
                
                const alpha = Math.sin(lifeProg * Math.PI) * this.p_baseAlpha[i] * alphaMult;
                const size = this.p_size[i] * (0.8 + this.breathValue * 0.8);

                // Direct draw (saving context save/restore for speed)
                this.ctx.globalAlpha = alpha;
                if(this.particleSprite) {
                    this.ctx.drawImage(this.particleSprite, this.p_x[i] - size/2, this.p_y[i] - size/2, size, size);
                }
            }
            this.ctx.globalAlpha = 1.0;
        }

        renderCircle() {
            const rBase = Math.min(this.width, this.height) * 0.3 * (0.4 + this.breathValue * 0.6);
            this.ctx.beginPath();
            const time = Date.now()*0.0003;
            for(let i=0; i<=100; i++) {
                const a = (i/100)*6.28;
                const n = this.noise.noise2D(Math.cos(a)+time, Math.sin(a));
                const r = rBase + n * 20 * this.breathValue;
                const x = this.centerX + Math.cos(a)*r, y = this.centerY + Math.sin(a)*r;
                if(i===0) this.ctx.moveTo(x,y); else this.ctx.lineTo(x,y);
            }
            this.ctx.closePath();
            this.ctx.strokeStyle = `rgba(${this.colors.r},${this.colors.g},${this.colors.b},0.3)`;
            this.ctx.stroke();
            const g = this.ctx.createRadialGradient(this.centerX, this.centerY, 0, this.centerX, this.centerY, rBase*1.2);
            g.addColorStop(0, `rgba(${this.colors.r},${this.colors.g},${this.colors.b},${0.3+this.breathValue*0.3})`);
            g.addColorStop(1, "rgba(0,0,0,0)");
            this.ctx.fillStyle = g; this.ctx.fill();
        }

        renderRipple() {
            const t = Date.now()*0.0005;
            for(let i=0; i<8; i++) {
                const r = (Math.min(this.width, this.height)*0.4) * ((i+1)/8) * (0.8 + this.breathValue * 0.2);
                this.ctx.beginPath();
                this.ctx.arc(this.centerX, this.centerY, r + Math.sin(t+i)*5, 0, 6.28);
                this.ctx.strokeStyle = `rgba(${this.colors.r},${this.colors.g},${this.colors.b},${0.1 + this.breathValue * 0.1})`;
                this.ctx.stroke();
            }
        }
    }

    /* --- AUDIO ENGINE --- */
    class GentleAudio {
        constructor() { 
            this.ctx = null; this.nodes = []; 
            this.masterGain = null;
            this.volume = parseFloat(localStorage.getItem('atem-volume')) || 0.3;
            this.audioEl = new Audio();
            this.audioEl.crossOrigin = "anonymous";
            this.audioEl.loop = true;
            this.mediaSource = null;
            this.bowlBuffer = null;
            this.waterBuffer = null;
            this.currentType = 'none';
            this.genNodes = {};
            this.reverbNode = null;
            this.musicGain = null;
        }
        async init() {
            const AC = window.AudioContext || window.webkitAudioContext;
            if (!this.ctx && AC) { 
                this.ctx = new AC();
                this.masterGain = this.ctx.createGain();
                this.masterGain.gain.value = this.volume;
                this.masterGain.connect(this.ctx.destination);
                
                this.musicGain = this.ctx.createGain();
                this.musicGain.gain.value = 0.25;
                this.musicGain.connect(this.masterGain);
                
                this.reverbNode = this.ctx.createConvolver();
                this.reverbNode.buffer = this.createReverbBuffer();
                this.reverbNode.connect(this.masterGain);
                
                this.mediaSource = this.ctx.createMediaElementSource(this.audioEl);
                this.mediaSource.connect(this.musicGain);
            }
            // Ensure running context (iOS fix)
            if (this.ctx && this.ctx.state === 'suspended') {
                await this.ctx.resume();
            }
        }
        setVolume(v) {
            this.volume = parseFloat(v); localStorage.setItem('atem-volume', this.volume);
            if(this.masterGain) this.masterGain.gain.setTargetAtTime(this.volume, this.ctx.currentTime, 0.1);
        }
        createReverbBuffer() {
            const len = this.ctx.sampleRate * 3.0;
            const buf = this.ctx.createBuffer(2, len, this.ctx.sampleRate);
            for(let c=0;c<2;c++){
                const d = buf.getChannelData(c);
                for(let i=0;i<len;i++) d[i] = (Math.random()*2-1)*Math.pow(1-i/len, 3);
            }
            return buf;
        }
        async loadBowl() {
            if(this.bowlBuffer) return;
            const file = 'e-flat-tibetan-singing-bowl-struck-38746.mp3';
            try {
                let ab;
                try {
                    const resp = await fetch(file);
                    if(!resp.ok) throw new Error('404');
                    ab = await resp.arrayBuffer();
                } catch(e) {
                    // Fallback: Versuche audio/ Ordner
                    const resp = await fetch('audio/' + file);
                    ab = await resp.arrayBuffer();
                }
                this.bowlBuffer = await this.ctx.decodeAudioData(ab);
            } catch(e) { console.warn("Bowl load failed", e); }
        }
        async loadWater() {
            if(this.waterBuffer) return;
            const file = 'flowing-water-loop-1-183953.mp3';
            try {
                let ab;
                try {
                    const resp = await fetch(file);
                    if(!resp.ok) throw new Error('404');
                    ab = await resp.arrayBuffer();
                } catch(e) {
                    const resp = await fetch('audio/' + file);
                    ab = await resp.arrayBuffer();
                }
                this.waterBuffer = await this.ctx.decodeAudioData(ab);
            } catch(e) { console.warn("Water load failed", e); }
        }
        updateGenerator(breathVal) {
            if ((this.currentType !== 'gentle' && this.currentType !== 'ambient') || !this.ctx) return;
            const t = this.ctx.currentTime;
            // Organic drift using non-repeating sine sums
            const drift = Math.sin(t * 0.2) * 4 + Math.sin(t * 0.37) * 4; 

            if (this.currentType === 'gentle') {
                // Gentle: Sine chord (F3 Major7-ish). Volume swells with breath.
                // Target gain: Soft (0.05) to Moderate (0.25) to avoid clipping 3 oscs
                const targetGain = 0.02 + (breathVal * 0.15);
                if(this.genNodes.gain) this.genNodes.gain.gain.setTargetAtTime(targetGain, t, 0.2);
                
                if(this.genNodes.oscs) {
                    this.genNodes.oscs.forEach((osc, i) => {
                        // Subtle detune drift for "human" feel
                        osc.detune.setTargetAtTime(drift * (i % 2 === 0 ? 1 : -1), t, 0.2);
                    });
                }
            } else if (this.currentType === 'ambient') {
                // Ambient: Deep Drone. Filter opens with breath.
                // Filter: 60Hz (closed) -> 280Hz (open)
                const targetFreq = 60 + (breathVal * 220);
                if(this.genNodes.filter) this.genNodes.filter.frequency.setTargetAtTime(targetFreq, t, 0.2);
                
                // Volume static or slight swell
                const targetGain = 0.08 + (breathVal * 0.04);
                if(this.genNodes.gain) this.genNodes.gain.gain.setTargetAtTime(targetGain, t, 0.2);
                // Detune is handled by initial setup + slight drift could be added here if needed
            }
        }
        triggerImpulse(pType) {
            if(!this.ctx) return;
            const t = this.ctx.currentTime;
            const osc = this.ctx.createOscillator();
            const g = this.ctx.createGain();
            osc.connect(g); g.connect(this.masterGain);
            if(this.reverbNode) g.connect(this.reverbNode);

            let f = 440;
            if(this.currentType === 'gentle') f = pType==='in' ? 698.46 : 523.25; // F5 / C5
            else f = pType==='in' ? 392.00 : 196.00; // G4 / G3

            osc.frequency.value = f; osc.type = 'sine';
            g.gain.setValueAtTime(0, t); g.gain.linearRampToValueAtTime(0.08, t+0.02);
            g.gain.exponentialRampToValueAtTime(0.001, t+2.5);
            osc.start(t); osc.stop(t+2.5);
            setTimeout(()=>{osc.disconnect();g.disconnect();}, 2600);
        }
        triggerBowl(semitones) {
            if(!this.bowlBuffer || !this.ctx) return;
            const src = this.ctx.createBufferSource();
            src.buffer = this.bowlBuffer;
            src.detune.value = semitones * 100;
            
            const g = this.ctx.createGain();
            g.gain.value = 0.25;
            src.connect(g); g.connect(this.masterGain);
            
            src.start(0);
            src.onended = () => { const i = this.nodes.indexOf(src); if(i>-1)this.nodes.splice(i,1); };
            this.nodes.push(src);
        }
        async play(type) {
            this.stop(); // Clear previous
            this.currentType = type;
            if (!this.ctx) await this.init();
            
            if (type === 'none') return;
            
            if (type === 'bowl') { await this.loadBowl(); return; }
            
            if (type === 'water') {
                await this.loadWater();
                if(!this.waterBuffer) return;
                const src = this.ctx.createBufferSource();
                src.buffer = this.waterBuffer;
                src.loop = true;
                const g = this.ctx.createGain();
                g.gain.value = 0; 
                g.gain.linearRampToValueAtTime(0.25, this.ctx.currentTime + 2.0);
                src.connect(g); g.connect(this.masterGain);
                src.start(0);
                this.nodes.push(src); this.nodes.push(g);
                return;
            }
            
            if (type === 'gentle' || type === 'ambient') {
                const master = this.ctx.createGain();
                master.connect(this.masterGain);
                master.gain.value = 0;
                // Fade in
                master.gain.linearRampToValueAtTime(0.1, this.ctx.currentTime + 2.0);
                this.nodes.push(master);
                
                this.genNodes = { gain: master, oscs: [] };

                if (type === 'gentle') {
                    // Harmonious Chord: F3 (174.61), C4 (261.63), A4 (440) -> F Major
                    // Using 174Hz (Solfeggio 'Healing') as base
                    const freqs = [174.61, 261.63, 349.23]; 
                    freqs.forEach((f, i) => {
                        const osc = this.ctx.createOscillator();
                        osc.type = 'sine'; osc.frequency.value = f;
                        osc.detune.value = (i * 5) - 5; // Spread frequencies slightly to reduce pressure
                        osc.connect(master); osc.start();
                        this.nodes.push(osc); this.genNodes.oscs.push(osc);
                    });
                } else {
                    // Ambient: Filtered Triangle Drone (C2 base)
                    const filter = this.ctx.createBiquadFilter();
                    filter.type = 'lowpass'; filter.frequency.value = 80; filter.Q.value = 0.5;
                    filter.connect(master); this.genNodes.filter = filter;
                    
                    [65.41, 98.00].forEach((f, i) => { // C2, G2
                        const osc = this.ctx.createOscillator();
                        osc.type = i === 0 ? 'sine' : 'triangle'; // Root as sine for cleaner bottom
                        osc.frequency.value = f;
                        osc.detune.value = i===0 ? -4 : 4; // Thickener
                        osc.connect(filter); osc.start();
                        this.nodes.push(osc); this.genNodes.oscs.push(osc);
                    });
                }
            } else {
                try {
                    this.audioEl.src = type;
                    // Reset to 0 for replay
                    this.audioEl.currentTime = 0;
                    await this.audioEl.play();
                } catch (e) {
                    console.warn("Audio play failed/aborted", e);
                }
            }
        }
        stop() { 
            // Cleanup oscillators
            this.nodes.forEach(n => { try{if(n.stop)n.stop();n.disconnect();}catch(e){} }); 
            this.nodes = []; 
            // Cleanup HTML Audio
            this.audioEl.pause();
        }
    }

    const quotes = [
        { t: "Atmen ist die Brücke zwischen Körper und Geist.", a: "Thich Nhat Hanh" },
        { t: "Im Atem liegt die Ruhe des Universums.", a: "Yogische Weisheit" },
        { t: "Lasse los und atme ein.", a: "Unbekannt" },
        { t: "Gefühle kommen und gehen wie Wolken. Der Atem ist mein Anker.", a: "Thich Nhat Hanh" }
    ];

    class BreathApp {
        constructor() {
            this.viz = new BreathVisuals(document.getElementById('viz-canvas'));
            this.audio = new GentleAudio();
            this.isRunning = false; 
            this.abortCtrl = null;
            this.sessionDuration = 0;
            this.startTime = 0;
            this.sessionTimerInterval = null;
            this.currentPreset = "";
            this.setupUI();
            this.randomizeVisuals();
            const p1Btn = document.querySelector(`.preset-scroll .chip[onclick*="'p1'"]`);
            this.loadPreset('p1', p1Btn);
        }

        setupUI() {
            document.getElementById('startBtn').addEventListener('click', () => this.toggle());
            document.getElementById('stop-float').addEventListener('click', () => this.stop());
            
            document.addEventListener('keydown', (e) => {
                if (e.code === 'Space' || e.key === ' ') {
                    e.preventDefault();
                    const summary = document.getElementById('summary-modal');
                    if (summary.classList.contains('visible')) {
                        this.closeSummary();
                    } else {
                        this.toggle();
                    }
                }
            });

            document.getElementById('themeSelect').addEventListener('change', (e) => {
                document.body.className = e.target.value; this.viz.updateThemeColors();
            });
            document.getElementById('soundSelect').addEventListener('change', (e) => {
                if(this.isRunning) this.audio.play(e.target.value);
            });
            document.getElementById('uploadBtn').addEventListener('click', () => document.getElementById('audioFileInput').click());
            document.getElementById('audioFileInput').addEventListener('change', (e) => {
                if(e.target.files[0]) {
                    const url = URL.createObjectURL(e.target.files[0]);
                    const sel = document.getElementById('soundSelect');
                    const opt = document.createElement('option');
                    opt.value = url; opt.text = "♫ " + e.target.files[0].name; opt.selected = true;
                    sel.add(opt);
                    if(this.isRunning) this.audio.play(url);
                }
            });
            
            const volSlider = document.getElementById('vol-slider');
            volSlider.value = this.audio.volume;
            this.updateVolumeIcon(this.audio.volume);
            
            volSlider.addEventListener('input', (e) => {
                const v = parseFloat(e.target.value);
                this.audio.setVolume(v);
                this.updateVolumeIcon(v);
            }, { passive: true });
        }

        randomizeVisuals() {
            const themes = ['theme-lotusabend', 'theme-dantian-gruen', 'theme-mani-glanz', 'theme-himmelblau', 'theme-goldene-ruhe', 'theme-reines-licht'];
            const randomTheme = themes[Math.floor(Math.random() * themes.length)];
            document.body.className = randomTheme;
            document.getElementById('themeSelect').value = randomTheme;
            this.viz.updateThemeColors();

            const modes = ['mist', 'circle', 'ripple'];
            const randomMode = modes[Math.floor(Math.random() * modes.length)];
            const modeBtn = document.querySelector(`.mode-row .chip[onclick*="'${randomMode}'"]`);
            this.setVisualMode(randomMode, modeBtn);
            
            const positions = ['pos-top', 'pos-center', 'pos-bottom'];
            const randomPos = positions[Math.floor(Math.random() * positions.length)];
            const vizArea = document.getElementById('visual-area');
            vizArea.classList.remove('pos-top', 'pos-center', 'pos-bottom');
            vizArea.classList.add(randomPos);
        }

        shuffleSession() {
            this.randomizeVisuals();
            
            const opts = Array.from(document.getElementById('soundSelect').options);
            const valid = opts.filter(o => o.value !== 'none').map(o => o.value);
            const rndSound = valid[Math.floor(Math.random() * valid.length)];
            document.getElementById('soundSelect').value = rndSound;
            if(this.isRunning) this.audio.play(rndSound);

            this.setDuration(0, document.querySelector('#duration-scroll .chip:first-child'));
        }

        loadPreset(k, el) {
            const presets = { 
                p1:[5.5,5.5], p2:[4,4], p3:[4,7,8], p4:[5,5,5,5], 
                p5:[6,6], p6:[7,7], p7:[8,8], p8:[5,5] 
            };
            const v = presets[k];
            if(!v) return;
            if(el) this.currentPreset = el.innerText;

            document.getElementById('inTime').value = v[0];
            document.getElementById('holdFullTime').value = v.length>2?v[1]:0;
            document.getElementById('outTime').value = v.length>2?v[2]:v[1];
            document.getElementById('holdEmptyTime').value = v.length==4?v[3]:0;

            const soundSelect = document.getElementById('soundSelect');
            if (k === 'p8') soundSelect.value = "audio/yrrpheus_coherence.mp3";
            else if (k === 'p1') soundSelect.value = "bowl";
            else soundSelect.value = "bowl";
            
            if (this.isRunning) this.audio.play(soundSelect.value);

            document.querySelectorAll('.preset-scroll .chip').forEach(c=>c.classList.remove('active'));
            if(el) el.classList.add('active');
        }
        
        setVisualMode(m, el) { 
            this.viz.mode = m; 
            document.querySelectorAll('.mode-row .chip').forEach(c=>c.classList.remove('active'));
            if(el) el.classList.add('active');
        }

        setDuration(min, el) {
            this.sessionDuration = parseInt(min);
            document.querySelectorAll('#duration-scroll .chip').forEach(c=>c.classList.remove('active'));
            if(el) el.classList.add('active');
        }

        toggleMute() {
            const slider = document.getElementById('vol-slider');
            if (this.audio.volume > 0) {
                this.audio.setVolume(0);
                slider.value = 0;
                this.updateVolumeIcon(0);
            } else {
                this.updateVolumeIcon(1); // Visual feedback only, user slides manually
            }
        }

        updateVolumeIcon(vol) {
            const path = document.querySelector('#vol-icon path');
            const isMuted = vol <= 0.01;
            document.getElementById('vol-icon').style.opacity = isMuted ? 0.5 : 0.9;
            if(isMuted) path.setAttribute('d', 'M16.5 12c0-1.77-1.02-3.29-2.5-4.03v2.21l2.45 2.45c.03-.2.05-.41.05-.63zm2.5 0c0 .94-.2 1.82-.54 2.64l1.51 1.51C20.63 14.91 21 13.5 21 12c0-4.28-2.99-7.86-7-8.77v2.06c2.89.86 5 3.54 5 6.71zM4.27 3L3 4.27 7.73 9H3v6h4l5 5v-6.73l4.25 4.25c-.67.52-1.42.93-2.25 1.18v2.06c1.38-.31 2.63-.95 3.69-1.81L19.73 21 21 19.73l-9-9L4.27 3zM12 4L9.91 6.09 12 8.18V4z');
            else path.setAttribute('d', 'M3 9v6h4l5 5V4L7 9H3zm13.5 3c0-1.77-1.02-3.29-2.5-4.03v8.05c1.48-.73 2.5-2.25 2.5-4.02zM14 3.23v2.06c2.89.86 5 3.54 5 6.71s-2.11 5.85-5 6.71v2.06c4.01-.91 7-4.49 7-8.77s-2.99-7.86-7-8.77z');
        }
        
        toggleUI() { document.getElementById('ui-container').classList.toggle('hidden'); }
        closeSummary() { document.getElementById('summary-modal').classList.remove('visible'); }
        
        async toggle() { this.isRunning ? this.stop() : this.start(); }

        async start() {
            if (this.isRunning) return;
            
            const btn = document.getElementById('startBtn');
            const oldText = btn.innerText;
            btn.innerText = "Laden...";
            btn.disabled = true;

            try {
                // Audio init & WakeLock
                await this.audio.init();
                await this.audio.play(document.getElementById('soundSelect').value);
                if(navigator.wakeLock) try { this.wakelock = await navigator.wakeLock.request('screen'); } catch(e){}

                this.isRunning = true;
                this.startTime = Date.now();
                
                document.getElementById('ui-container').classList.add('hidden');
                document.body.classList.add('ui-hidden');
                document.getElementById('summary-modal').classList.remove('visible');
                btn.innerText = "Beenden";
                btn.classList.add('stop-mode');
                btn.disabled = false;
                document.getElementById('stop-float').style.display = 'block';
                
                document.getElementById('preset-display').innerText = this.currentPreset || "Freies Atmen";
                document.getElementById('preset-display').classList.add('visible');
                
                // Cleanup old controller if exists
                if(this.abortCtrl) this.abortCtrl.abort();
                this.abortCtrl = new AbortController();
                
                this.loop(this.abortCtrl.signal);

                document.getElementById('session-timer').classList.add('visible');
                this.updateSessionTimer();
                // Clear any existing interval
                if(this.sessionTimerInterval) clearInterval(this.sessionTimerInterval);
                this.sessionTimerInterval = setInterval(() => this.updateSessionTimer(), 1000);
                
            } catch (err) {
                console.error(err);
                this.isRunning = false;
                btn.innerText = oldText;
                btn.disabled = false;
            }
        }

        stop() {
            this.isRunning = false;
            if(this.abortCtrl) { this.abortCtrl.abort(); this.abortCtrl = null; }
            this.audio.stop();
            if(this.sessionTimerInterval) clearInterval(this.sessionTimerInterval);
            document.getElementById('session-timer').classList.remove('visible');
            document.getElementById('preset-display').classList.remove('visible');

            if(this.wakelock) this.wakelock.release();
            
            document.getElementById('ui-container').classList.remove('hidden');
            document.body.classList.remove('ui-hidden');
            document.getElementById('startBtn').innerText = "Beginnen";
            document.getElementById('startBtn').classList.remove('stop-mode');
            document.getElementById('stop-float').style.display = 'none';
            
            const instr = document.getElementById('instruction');
            instr.innerText = "Atmen";
            instr.style.color = '';
            document.getElementById('breath-timer').innerText = "";
            this.viz.setBreathState(0.5, 'hold-empty');
            
            const elapsedSec = Math.floor((Date.now() - this.startTime) / 1000);
            
            if (elapsedSec >= 30) {
                const m = Math.floor(elapsedSec / 60);
                const s = elapsedSec % 60;
                document.getElementById('summary-time').innerText = `${m} Minuten und ${s} Sekunden`;

                const q = quotes[Math.floor(Math.random()*quotes.length)];
                document.getElementById('quote-text').innerText = q.t;
                document.getElementById('quote-author').innerText = q.a;
                document.getElementById('summary-modal').classList.add('visible');
            }
        }

        updateSessionTimer() {
            const elapsed = Date.now() - this.startTime;
            if (this.sessionDuration > 0) {
                const totalMs = this.sessionDuration * 60 * 1000;
                const remaining = Math.max(0, totalMs - elapsed);
                const m = Math.floor(remaining / 60000);
                const s = Math.floor((remaining % 60000) / 1000);
                document.getElementById('session-timer').innerText = `${m.toString().padStart(2, '0')}:${s.toString().padStart(2, '0')}`;
                if (remaining <= 0) this.stop();
            } else {
                const m = Math.floor(elapsed / 60000);
                const s = Math.floor((elapsed % 60000) / 1000);
                document.getElementById('session-timer').innerText = `${m.toString().padStart(2, '0')}:${s.toString().padStart(2, '0')}`;
            }
        }

        async loop(signal) {
            const val = id => parseFloat(document.getElementById(id).value) || 0;
            // The isRunning check here ensures we don't start a new loop if stop() was called during a phase transition
            while(!signal.aborted && this.isRunning) {
                await this.phase("Einatmen", val('inTime'), 0, 1, '#82B1FF', signal, true);
                await this.phase("Halten", val('holdFullTime'), 1, 1, '#D1D1D1', signal, false);
                await this.phase("Ausatmen", val('outTime'), 1, 0, '#EF9A9A', signal, false);
                await this.phase("Pause", val('holdEmptyTime'), 0, 0, '#D1D1D1', signal, false);
            }
        }
        
        async phase(text, dur, startV, endV, col, signal, countUp) {
            if(signal.aborted || !this.isRunning || dur <= 0) return;
            
            const instr = document.getElementById('instruction');
            instr.innerText = text;
            instr.style.color = col;
            
            let pType = 'hold-empty';
            if (startV < endV) pType = 'in';
            else if (startV > endV) pType = 'out';
            else if (startV === 1) pType = 'hold-full';
            
            if (this.audio.currentType === 'bowl') {
                if (pType === 'in') this.audio.triggerBowl(0);
                else if (pType === 'out') this.audio.triggerBowl(-5);
            } else if (this.audio.currentType === 'gentle' || this.audio.currentType === 'ambient') {
                if (pType === 'in' || pType === 'out') this.audio.triggerImpulse(pType);
            }
            
            const start = Date.now();
            return new Promise(resolve => {
                const tick = () => {
                    if(signal.aborted || !this.isRunning) return resolve();
                    
                    const now = Date.now();
                    const prog = Math.min(1, (now - start)/(dur*1000));
                    const eased = 0.5 * (1 - Math.cos(Math.PI * prog)); 
                    const currentBreath = startV + (endV - startV) * eased;
                    
                    this.viz.setBreathState(currentBreath, pType);
                    this.audio.updateGenerator(currentBreath);
                    
                    const timeVal = countUp ? (dur * prog) : (dur - (dur * prog));
                    const timer = document.getElementById('breath-timer');
                    timer.innerText = timeVal.toFixed(0); 
                    timer.style.color = col;
                    
                    if(prog < 1) requestAnimationFrame(tick); else resolve();
                };
                tick();
            });
        }
    }

    document.addEventListener('DOMContentLoaded', () => window.app = new BreathApp());
    </script>
</body>
</html>
